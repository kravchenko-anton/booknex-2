"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-activity-calendar";
exports.ids = ["vendor-chunks/react-activity-calendar"];
exports.modules = {

/***/ "(ssr)/../../node_modules/react-activity-calendar/build/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/react-activity-calendar/build/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar chroma = __webpack_require__(/*! chroma-js */ \"(ssr)/../../node_modules/chroma-js/chroma.js\");\nvar dateFns = __webpack_require__(/*! date-fns */ \"(ssr)/../../node_modules/date-fns/esm/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar chroma__default = /*#__PURE__*/ _interopDefault(chroma);\nvar React__default = /*#__PURE__*/ _interopDefault(React);\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nconst NAMESPACE = \"react-activity-calendar\";\nconst LABEL_MARGIN = 8; // px\nconst DEFAULT_MONTH_LABELS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nconst DEFAULT_LABELS = {\n    months: DEFAULT_MONTH_LABELS,\n    weekdays: [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ],\n    totalCount: \"{{count}} activities in {{year}}\",\n    legend: {\n        less: \"Less\",\n        more: \"More\"\n    }\n};\nfunction useColorScheme() {\n    const [colorScheme, setColorScheme] = React.useState(\"light\");\n    const onChange = (event)=>setColorScheme(event.matches ? \"dark\" : \"light\");\n    React.useEffect(()=>{\n        const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n        setColorScheme(mediaQuery.matches ? \"dark\" : \"light\");\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return colorScheme;\n}\nconst query = \"(prefers-reduced-motion: reduce)\";\nfunction usePrefersReducedMotion() {\n    const [prefersReducedMotion, setPrefersReducedMotion] = React.useState(true);\n    React.useEffect(()=>{\n        const mediaQuery = window.matchMedia(query);\n        setPrefersReducedMotion(mediaQuery.matches);\n        const onChange = (event)=>{\n            setPrefersReducedMotion(event.matches);\n        };\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return prefersReducedMotion;\n}\nfunction styleInject(css, ref) {\n    if (ref === void 0) ref = {};\n    var insertAt = ref.insertAt;\n    if (!css || typeof document === \"undefined\") {\n        return;\n    }\n    var head = document.head || document.getElementsByTagName(\"head\")[0];\n    var style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    if (insertAt === \"top\") {\n        if (head.firstChild) {\n            head.insertBefore(style, head.firstChild);\n        } else {\n            head.appendChild(style);\n        }\n    } else {\n        head.appendChild(style);\n    }\n    if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        style.appendChild(document.createTextNode(css));\n    }\n}\nvar css_248z = \".styles-module_container__GBNxC {\\n  width: max-content; /* Calendar should not grow */\\n  max-width: 100%; /* Do not remove - flexbox parents */\\n  display: flex;\\n  flex-direction: column;\\n  gap: 8px;\\n}\\n\\n.styles-module_container__GBNxC rect {\\n  stroke: rgba(0, 0, 0, 0.08);\\n  stroke-width: 1px;\\n  shape-rendering: geometricPrecision;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .styles-module_container__GBNxC rect {\\n    stroke: rgba(255, 255, 255, 0.04);\\n  }\\n}\\n\\n.styles-module_scrollContainer__-bJC8 {\\n  max-width: 100%;\\n  overflow-x: auto;\\n  overflow-y: hidden;\\n}\\n\\n.styles-module_calendar__sT1ND {\\n  display: block; /* SVGs are inline-block by default */\\n  overflow: visible; /* Weekday labels are rendered left of the container */\\n}\\n\\n.styles-module_calendar__sT1ND text {\\n  fill: currentColor;\\n}\\n\\n.styles-module_footer__ZQ-Bl {\\n  display: flex;\\n  flex-wrap: wrap;\\n  gap: 4px 16px;\\n  white-space: nowrap;\\n}\\n\\n.styles-module_legendColors__kFY2e {\\n  margin-left: auto;\\n  display: flex;\\n  align-items: center;\\n  gap: 3px;\\n}\\n\\n@keyframes styles-module_loadingAnimation__V0w3h {\\n  0% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n  50% {\\n    fill: var(--react-activity-calendar-loading-active);\\n  }\\n  100% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n}\\n\";\nvar styles = {\n    \"container\": \"styles-module_container__GBNxC\",\n    \"scrollContainer\": \"styles-module_scrollContainer__-bJC8\",\n    \"calendar\": \"styles-module_calendar__sT1ND\",\n    \"footer\": \"styles-module_footer__ZQ-Bl\",\n    \"legendColors\": \"styles-module_legendColors__kFY2e\",\n    \"loadingAnimation\": \"styles-module_loadingAnimation__V0w3h\"\n};\nstyleInject(css_248z);\nfunction groupByWeeks(activities, weekStart = 0 // 0 = Sunday\n) {\n    if (activities.length === 0) {\n        return [];\n    }\n    const normalizedActivities = fillHoles(activities);\n    // Determine the first date of the calendar. If the first date is not the\n    // set start weekday, the selected weekday one week earlier is used.\n    const firstDate = dateFns.parseISO(normalizedActivities[0].date);\n    const firstCalendarDate = dateFns.getDay(firstDate) === weekStart ? firstDate : dateFns.subWeeks(dateFns.nextDay(firstDate, weekStart), 1);\n    // To correctly group activities by week, it is necessary to left-pad the list\n    // because the first date might not be set start weekday.\n    const paddedActivities = [\n        ...Array(dateFns.differenceInCalendarDays(firstDate, firstCalendarDate)).fill(undefined),\n        ...normalizedActivities\n    ];\n    const numberOfWeeks = Math.ceil(paddedActivities.length / 7);\n    // Finally, group activities by week\n    return Array(numberOfWeeks).fill(undefined).map((_, weekIndex)=>paddedActivities.slice(weekIndex * 7, weekIndex * 7 + 7));\n}\n/**\n * The calendar expects a continuous sequence of days,\n * so fill gaps with empty activity data.\n */ function fillHoles(activities) {\n    const dateMap = {};\n    for (const activity of activities){\n        dateMap[activity.date] = activity;\n    }\n    return dateFns.eachDayOfInterval({\n        start: dateFns.parseISO(activities[0].date),\n        end: dateFns.parseISO(activities[activities.length - 1].date)\n    }).map((day)=>{\n        const date = dateFns.formatISO(day, {\n            representation: \"date\"\n        });\n        if (dateMap[date]) {\n            return dateMap[date];\n        }\n        return {\n            date,\n            count: 0,\n            level: 0\n        };\n    });\n}\nfunction getMonthLabels(weeks, monthNames = DEFAULT_MONTH_LABELS) {\n    return weeks.reduce((labels, week, weekIndex)=>{\n        const firstActivity = week.find((activity)=>activity !== undefined);\n        if (!firstActivity) {\n            throw new Error(`Unexpected error: Week ${weekIndex + 1} is empty: [${week}].`);\n        }\n        const month = monthNames[dateFns.getMonth(dateFns.parseISO(firstActivity.date))];\n        const prevLabel = labels[labels.length - 1];\n        if (weekIndex === 0 || prevLabel.label !== month) {\n            return [\n                ...labels,\n                {\n                    weekIndex,\n                    label: month\n                }\n            ];\n        }\n        return labels;\n    }, []).filter(({ weekIndex }, index, labels)=>{\n        // Labels should only be shown if there is \"enough\" space (data).\n        // This is a naive implementation that does not take the block size,\n        // font size etc. into account.\n        const minWeeks = 3;\n        // Skip the first month label if there is not enough space to the next one.\n        if (index === 0) {\n            return labels[1] && labels[1].weekIndex - weekIndex >= minWeeks;\n        }\n        // Skip the last month label the there is not enough data in that month to\n        // avoid overflowing the calendar on the right.\n        if (index === labels.length - 1) {\n            return weeks.slice(weekIndex).length >= minWeeks;\n        }\n        return true;\n    });\n}\nfunction getClassName(name, styles) {\n    if (styles) {\n        return `${NAMESPACE}__${name} ${styles}`;\n    }\n    return `${NAMESPACE}__${name}`;\n}\nfunction generateEmptyData() {\n    const year = new Date().getFullYear();\n    const days = dateFns.eachDayOfInterval({\n        start: new Date(year, 0, 1),\n        end: new Date(year, 11, 31)\n    });\n    return days.map((date)=>({\n            date: dateFns.formatISO(date, {\n                representation: \"date\"\n            }),\n            count: 0,\n            level: 0\n        }));\n}\nfunction maxWeekdayLabelLength(firstWeek, weekStart, labels, fontSize) {\n    return firstWeek.reduce((maxLength, _, index)=>{\n        if (index % 2 !== 0) {\n            const dayIndex = (index + weekStart) % 7;\n            const curLength = Math.ceil(calcTextDimensions(labels[dayIndex], fontSize).width);\n            return Math.max(maxLength, curLength);\n        }\n        return maxLength;\n    }, 0);\n}\nfunction calcTextDimensions(text, fontSize) {\n    if (typeof document === \"undefined\" || \"undefined\" === \"undefined\") {\n        throw new Error(\"calcTextDimensions() requires browser APIs\");\n    }\n    if (fontSize < 1) {\n        throw new RangeError(\"fontSize must be positive\");\n    }\n    if (text.length === 0) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    const namespace = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(namespace, \"svg\");\n    svg.style.position = \"absolute\";\n    svg.style.visibility = \"hidden\";\n    svg.style.fontFamily = window.getComputedStyle(document.body).fontFamily;\n    svg.style.fontSize = `${fontSize}px`;\n    const textNode = document.createElementNS(namespace, \"text\");\n    textNode.textContent = text;\n    svg.appendChild(textNode);\n    document.body.appendChild(svg);\n    const boundingBox = textNode.getBBox();\n    document.body.removeChild(svg);\n    return {\n        width: boundingBox.width,\n        height: boundingBox.height\n    };\n}\nfunction createTheme(input, size = 5) {\n    const defaultTheme = createDefaultTheme(size);\n    if (input) {\n        validateTheme(input, size);\n        input.light = input.light ?? defaultTheme.light;\n        input.dark = input.dark ?? defaultTheme.dark;\n        return {\n            light: isColorScale(input.light, size) ? input.light : createColorScale(input.light, size),\n            dark: isColorScale(input.dark, size) ? input.dark : createColorScale(input.dark, size)\n        };\n    }\n    return defaultTheme;\n}\nfunction createDefaultTheme(size) {\n    return {\n        light: createColorScale([\n            \"hsl(0, 0%, 92%)\",\n            \"hsl(0, 0%, 26%)\"\n        ], size),\n        dark: createColorScale([\n            \"hsl(0, 0%, 20%)\",\n            \"hsl(0, 0%, 92%)\"\n        ], size)\n    };\n}\nfunction validateTheme(input, size) {\n    if (typeof input !== \"object\" || input.light === undefined && input.dark === undefined) {\n        throw new Error(`The theme object must contain at least one of the fields \"light\" and \"dark\" with exactly 2 or ${size} colors respectively.`);\n    }\n    if (input.light) {\n        const { length } = input.light;\n        if (length !== 2 && length !== size) {\n            throw new Error(`theme.light must contain exactly 2 or ${size} colors, ${length} passed.`);\n        }\n    }\n    if (input.dark) {\n        const { length } = input.dark;\n        if (length !== 2 && length !== size) {\n            throw new Error(`theme.dark must contain exactly 2 or ${size} colors, ${length} passed.`);\n        }\n    }\n}\nfunction isColorScale(colors, size) {\n    const invalidColor = colors.find((color)=>!chroma__default.default.valid(color));\n    if (invalidColor) {\n        throw new Error(`Invalid color \"${invalidColor}\" passed. All CSS color formats are accepted.`);\n    }\n    return colors.length === size;\n}\nfunction createColorScale(colors, size) {\n    return chroma__default.default.scale(colors).mode(\"lch\").colors(size);\n}\nconst ActivityCalendar = ({ data, blockMargin = 4, blockRadius = 2, blockSize = 12, colorScheme = undefined, eventHandlers = {}, fontSize = 14, hideColorLegend = false, hideMonthLabels = false, hideTotalCount = false, labels: labelsProp = undefined, maxLevel = 4, loading = false, renderBlock = undefined, showWeekdayLabels = false, style: styleProp = {}, theme: themeProp = undefined, totalCount: totalCountProp = undefined, weekStart = 0 // Sunday\n })=>{\n    maxLevel = Math.max(1, maxLevel);\n    const theme = createTheme(themeProp, maxLevel + 1);\n    const systemColorScheme = useColorScheme();\n    const colorScale = theme[colorScheme ?? systemColorScheme];\n    const useAnimation = !usePrefersReducedMotion();\n    if (loading) {\n        data = generateEmptyData();\n    }\n    if (data.length === 0) {\n        return null;\n    }\n    const year = dateFns.getYear(dateFns.parseISO(data[0]?.date));\n    const weeks = groupByWeeks(data, weekStart);\n    const labels = Object.assign({}, DEFAULT_LABELS, labelsProp);\n    const labelHeight = hideMonthLabels ? 0 : fontSize + LABEL_MARGIN;\n    const weekdayLabelOffset = showWeekdayLabels ? maxWeekdayLabelLength(weeks[0], weekStart, labels.weekdays, fontSize) + LABEL_MARGIN : undefined;\n    function getDimensions() {\n        return {\n            width: weeks.length * (blockSize + blockMargin) - blockMargin,\n            height: labelHeight + (blockSize + blockMargin) * 7 - blockMargin\n        };\n    }\n    function getEventHandlers(activity) {\n        return Object.keys(eventHandlers).reduce((handlers, key)=>({\n                ...handlers,\n                [key]: (event)=>eventHandlers[key]?.(event)(activity)\n            }), {});\n    }\n    function renderCalendar() {\n        return weeks.map((week, weekIndex)=>week.map((activity, dayIndex)=>{\n                if (!activity) {\n                    return null;\n                }\n                if (activity.level < 0 || activity.level > maxLevel) {\n                    throw new RangeError(`Provided activity level ${activity.level} for ${activity.date} is out of range. It must be between 0 and ${maxLevel}.`);\n                }\n                const style = loading && useAnimation ? {\n                    animation: `${styles.loadingAnimation} 1.75s ease-in-out infinite`,\n                    animationDelay: `${weekIndex * 20 + dayIndex * 20}ms`\n                } : undefined;\n                const block = /*#__PURE__*/ React__default.default.createElement(\"rect\", _extends({}, getEventHandlers(activity), {\n                    x: 0,\n                    y: labelHeight + (blockSize + blockMargin) * dayIndex,\n                    width: blockSize,\n                    height: blockSize,\n                    rx: blockRadius,\n                    ry: blockRadius,\n                    fill: colorScale[activity.level],\n                    \"data-date\": activity.date,\n                    \"data-level\": activity.level,\n                    style: style\n                }));\n                return /*#__PURE__*/ React__default.default.createElement(React.Fragment, {\n                    key: activity.date\n                }, renderBlock ? renderBlock(block, activity) : block);\n            })).map((week, x)=>/*#__PURE__*/ React__default.default.createElement(\"g\", {\n                key: x,\n                transform: `translate(${(blockSize + blockMargin) * x}, 0)`\n            }, week));\n    }\n    function renderFooter() {\n        if (hideTotalCount && hideColorLegend) {\n            return null;\n        }\n        const totalCount = typeof totalCountProp === \"number\" ? totalCountProp : data.reduce((sum, activity)=>sum + activity.count, 0);\n        return /*#__PURE__*/ React__default.default.createElement(\"footer\", {\n            className: getClassName(\"footer\", styles.footer),\n            style: {\n                marginLeft: weekdayLabelOffset\n            }\n        }, loading && /*#__PURE__*/ React__default.default.createElement(\"div\", null, \"\\xa0\"), !loading && !hideTotalCount && /*#__PURE__*/ React__default.default.createElement(\"div\", {\n            className: getClassName(\"count\")\n        }, labels.totalCount ? labels.totalCount.replace(\"{{count}}\", String(totalCount)).replace(\"{{year}}\", String(year)) : `${totalCount} activities in ${year}`), !loading && !hideColorLegend && /*#__PURE__*/ React__default.default.createElement(\"div\", {\n            className: getClassName(\"legend-colors\", styles.legendColors)\n        }, /*#__PURE__*/ React__default.default.createElement(\"span\", {\n            style: {\n                marginRight: \"0.4em\"\n            }\n        }, labels?.legend?.less ?? \"Less\"), Array(maxLevel + 1).fill(undefined).map((_, level)=>/*#__PURE__*/ React__default.default.createElement(\"svg\", {\n                width: blockSize,\n                height: blockSize,\n                key: level\n            }, /*#__PURE__*/ React__default.default.createElement(\"rect\", {\n                width: blockSize,\n                height: blockSize,\n                fill: colorScale[level],\n                rx: blockRadius,\n                ry: blockRadius\n            }))), /*#__PURE__*/ React__default.default.createElement(\"span\", {\n            style: {\n                marginLeft: \"0.4em\"\n            }\n        }, labels?.legend?.more ?? \"More\")));\n    }\n    function renderLabels() {\n        if (!showWeekdayLabels && hideMonthLabels) {\n            return null;\n        }\n        return /*#__PURE__*/ React__default.default.createElement(React__default.default.Fragment, null, showWeekdayLabels && /*#__PURE__*/ React__default.default.createElement(\"g\", {\n            className: getClassName(\"legend-weekday\")\n        }, weeks[0].map((_, index)=>{\n            if (index % 2 === 0) {\n                return null;\n            }\n            const dayIndex = (index + weekStart) % 7;\n            return /*#__PURE__*/ React__default.default.createElement(\"text\", {\n                x: -LABEL_MARGIN,\n                y: labelHeight + (blockSize + blockMargin) * index + blockSize / 2,\n                dominantBaseline: \"middle\",\n                textAnchor: \"end\",\n                key: index\n            }, labels.weekdays[dayIndex]);\n        })), !hideMonthLabels && /*#__PURE__*/ React__default.default.createElement(\"g\", {\n            className: getClassName(\"legend-month\")\n        }, getMonthLabels(weeks, labels.months).map(({ label, weekIndex })=>/*#__PURE__*/ React__default.default.createElement(\"text\", {\n                x: (blockSize + blockMargin) * weekIndex,\n                dominantBaseline: \"hanging\",\n                key: weekIndex\n            }, label))));\n    }\n    const { width, height } = getDimensions();\n    const containerStyles = {\n        fontSize,\n        ...useAnimation && {\n            [`--${NAMESPACE}-loading`]: colorScale[0],\n            [`--${NAMESPACE}-loading-active`]: colorScheme === \"light\" ? chroma__default.default(colorScale[0]).darken(0.3).hex() : chroma__default.default(colorScale[0]).brighten(0.25).hex()\n        }\n    };\n    return /*#__PURE__*/ React__default.default.createElement(\"article\", {\n        className: `${NAMESPACE} ${styles.container}`,\n        style: {\n            ...styleProp,\n            ...containerStyles\n        }\n    }, /*#__PURE__*/ React__default.default.createElement(\"div\", {\n        className: getClassName(\"scroll-container\", styles.scrollContainer)\n    }, /*#__PURE__*/ React__default.default.createElement(\"svg\", {\n        width: width,\n        height: height,\n        viewBox: `0 0 ${width} ${height}`,\n        className: getClassName(\"calendar\", styles.calendar),\n        style: {\n            marginLeft: weekdayLabelOffset\n        }\n    }, !loading && renderLabels(), renderCalendar())), renderFooter());\n};\nconst Skeleton = (props)=>/*#__PURE__*/ React__default.default.createElement(ActivityCalendar, _extends({\n        data: []\n    }, props));\nexports.Skeleton = Skeleton;\nexports[\"default\"] = ActivityCalendar; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWFjdGl2aXR5LWNhbGVuZGFyL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJxREFDQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN0QixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUVwQixTQUFTRyxnQkFBaUJDLENBQUM7SUFBSSxPQUFPQSxLQUFLQSxFQUFFQyxVQUFVLEdBQUdELElBQUk7UUFBRUUsU0FBU0Y7SUFBRTtBQUFHO0FBRTlFLElBQUlHLGtCQUFrQixXQUFXLEdBQUVKLGdCQUFnQko7QUFDbkQsSUFBSVMsaUJBQWlCLFdBQVcsR0FBRUwsZ0JBQWdCRDtBQUVsRCxTQUFTTztJQUNQQSxXQUFXZCxPQUFPZSxNQUFNLEdBQUdmLE9BQU9lLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJckIsT0FBT3VCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0gsU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSxNQUFNUSxZQUFZO0FBQ2xCLE1BQU1DLGVBQWUsR0FBRyxLQUFLO0FBRTdCLE1BQU1DLHVCQUF1QjtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFB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aE4sZUFBZUYsT0FBTyxDQUFDbUQsYUFBYSxDQUFDLE9BQU87UUFDMURxSixXQUFXekYsYUFBYSxvQkFBb0JuRCxPQUFPMkosZUFBZTtJQUNwRSxHQUFHLFdBQVcsR0FBRXJOLGVBQWVGLE9BQU8sQ0FBQ21ELGFBQWEsQ0FBQyxPQUFPO1FBQzFEMEUsT0FBT0E7UUFDUEksUUFBUUE7UUFDUnVGLFNBQVMsQ0FBQyxJQUFJLEVBQUUzRixNQUFNLENBQUMsRUFBRUksT0FBTyxDQUFDO1FBQ2pDdUUsV0FBV3pGLGFBQWEsWUFBWW5ELE9BQU82SixRQUFRO1FBQ25EdkssT0FBTztZQUNMd0osWUFBWXBCO1FBQ2Q7SUFDRixHQUFHLENBQUNaLFdBQVdxQyxnQkFBZ0JwQixvQkFBb0JXO0FBQ3JEO0FBQ0EsTUFBTW9CLFdBQVdDLENBQUFBLFFBQVMsV0FBVyxHQUFFek4sZUFBZUYsT0FBTyxDQUFDbUQsYUFBYSxDQUFDNEcsa0JBQWtCNUosU0FBUztRQUNyRzZKLE1BQU0sRUFBRTtJQUNWLEdBQUcyRDtBQUVIcE8sZ0JBQWdCLEdBQUdtTztBQUNuQm5PLGtCQUFlLEdBQUd3SyxrQkFDbEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1hY3Rpdml0eS1jYWxlbmRhci9idWlsZC9pbmRleC5qcz9iZjViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50Jztcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNocm9tYSA9IHJlcXVpcmUoJ2Nocm9tYS1qcycpO1xudmFyIGRhdGVGbnMgPSByZXF1aXJlKCdkYXRlLWZucycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG52YXIgY2hyb21hX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChjaHJvbWEpO1xudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChSZWFjdCk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5jb25zdCBOQU1FU1BBQ0UgPSAncmVhY3QtYWN0aXZpdHktY2FsZW5kYXInO1xuY29uc3QgTEFCRUxfTUFSR0lOID0gODsgLy8gcHhcblxuY29uc3QgREVGQVVMVF9NT05USF9MQUJFTFMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5jb25zdCBERUZBVUxUX0xBQkVMUyA9IHtcbiAgbW9udGhzOiBERUZBVUxUX01PTlRIX0xBQkVMUyxcbiAgd2Vla2RheXM6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIHRvdGFsQ291bnQ6ICd7e2NvdW50fX0gYWN0aXZpdGllcyBpbiB7e3llYXJ9fScsXG4gIGxlZ2VuZDoge1xuICAgIGxlc3M6ICdMZXNzJyxcbiAgICBtb3JlOiAnTW9yZSdcbiAgfVxufTtcblxuZnVuY3Rpb24gdXNlQ29sb3JTY2hlbWUoKSB7XG4gIGNvbnN0IFtjb2xvclNjaGVtZSwgc2V0Q29sb3JTY2hlbWVdID0gUmVhY3QudXNlU3RhdGUoJ2xpZ2h0Jyk7XG4gIGNvbnN0IG9uQ2hhbmdlID0gZXZlbnQgPT4gc2V0Q29sb3JTY2hlbWUoZXZlbnQubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCcpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpO1xuICAgIHNldENvbG9yU2NoZW1lKG1lZGlhUXVlcnkubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCcpO1xuICAgIG1lZGlhUXVlcnkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtZWRpYVF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBjb2xvclNjaGVtZTtcbn1cblxuY29uc3QgcXVlcnkgPSAnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSknO1xuZnVuY3Rpb24gdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24oKSB7XG4gIGNvbnN0IFtwcmVmZXJzUmVkdWNlZE1vdGlvbiwgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb25dID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWVkaWFRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KTtcbiAgICBzZXRQcmVmZXJzUmVkdWNlZE1vdGlvbihtZWRpYVF1ZXJ5Lm1hdGNoZXMpO1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gZXZlbnQgPT4ge1xuICAgICAgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24oZXZlbnQubWF0Y2hlcyk7XG4gICAgfTtcbiAgICBtZWRpYVF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVkaWFRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gcHJlZmVyc1JlZHVjZWRNb3Rpb247XG59XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6ID0gXCIuc3R5bGVzLW1vZHVsZV9jb250YWluZXJfX0dCTnhDIHtcXG4gIHdpZHRoOiBtYXgtY29udGVudDsgLyogQ2FsZW5kYXIgc2hvdWxkIG5vdCBncm93ICovXFxuICBtYXgtd2lkdGg6IDEwMCU7IC8qIERvIG5vdCByZW1vdmUgLSBmbGV4Ym94IHBhcmVudHMgKi9cXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZ2FwOiA4cHg7XFxufVxcblxcbi5zdHlsZXMtbW9kdWxlX2NvbnRhaW5lcl9fR0JOeEMgcmVjdCB7XFxuICBzdHJva2U6IHJnYmEoMCwgMCwgMCwgMC4wOCk7XFxuICBzdHJva2Utd2lkdGg6IDFweDtcXG4gIHNoYXBlLXJlbmRlcmluZzogZ2VvbWV0cmljUHJlY2lzaW9uO1xcbn1cXG5cXG5AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxuICAuc3R5bGVzLW1vZHVsZV9jb250YWluZXJfX0dCTnhDIHJlY3Qge1xcbiAgICBzdHJva2U6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNCk7XFxuICB9XFxufVxcblxcbi5zdHlsZXMtbW9kdWxlX3Njcm9sbENvbnRhaW5lcl9fLWJKQzgge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgb3ZlcmZsb3cteDogYXV0bztcXG4gIG92ZXJmbG93LXk6IGhpZGRlbjtcXG59XFxuXFxuLnN0eWxlcy1tb2R1bGVfY2FsZW5kYXJfX3NUMU5EIHtcXG4gIGRpc3BsYXk6IGJsb2NrOyAvKiBTVkdzIGFyZSBpbmxpbmUtYmxvY2sgYnkgZGVmYXVsdCAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7IC8qIFdlZWtkYXkgbGFiZWxzIGFyZSByZW5kZXJlZCBsZWZ0IG9mIHRoZSBjb250YWluZXIgKi9cXG59XFxuXFxuLnN0eWxlcy1tb2R1bGVfY2FsZW5kYXJfX3NUMU5EIHRleHQge1xcbiAgZmlsbDogY3VycmVudENvbG9yO1xcbn1cXG5cXG4uc3R5bGVzLW1vZHVsZV9mb290ZXJfX1pRLUJsIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICBnYXA6IDRweCAxNnB4O1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuXFxuLnN0eWxlcy1tb2R1bGVfbGVnZW5kQ29sb3JzX19rRlkyZSB7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZ2FwOiAzcHg7XFxufVxcblxcbkBrZXlmcmFtZXMgc3R5bGVzLW1vZHVsZV9sb2FkaW5nQW5pbWF0aW9uX19WMHczaCB7XFxuICAwJSB7XFxuICAgIGZpbGw6IHZhcigtLXJlYWN0LWFjdGl2aXR5LWNhbGVuZGFyLWxvYWRpbmcpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgZmlsbDogdmFyKC0tcmVhY3QtYWN0aXZpdHktY2FsZW5kYXItbG9hZGluZy1hY3RpdmUpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIGZpbGw6IHZhcigtLXJlYWN0LWFjdGl2aXR5LWNhbGVuZGFyLWxvYWRpbmcpO1xcbiAgfVxcbn1cXG5cIjtcbnZhciBzdHlsZXMgPSB7XCJjb250YWluZXJcIjpcInN0eWxlcy1tb2R1bGVfY29udGFpbmVyX19HQk54Q1wiLFwic2Nyb2xsQ29udGFpbmVyXCI6XCJzdHlsZXMtbW9kdWxlX3Njcm9sbENvbnRhaW5lcl9fLWJKQzhcIixcImNhbGVuZGFyXCI6XCJzdHlsZXMtbW9kdWxlX2NhbGVuZGFyX19zVDFORFwiLFwiZm9vdGVyXCI6XCJzdHlsZXMtbW9kdWxlX2Zvb3Rlcl9fWlEtQmxcIixcImxlZ2VuZENvbG9yc1wiOlwic3R5bGVzLW1vZHVsZV9sZWdlbmRDb2xvcnNfX2tGWTJlXCIsXCJsb2FkaW5nQW5pbWF0aW9uXCI6XCJzdHlsZXMtbW9kdWxlX2xvYWRpbmdBbmltYXRpb25fX1YwdzNoXCJ9O1xuc3R5bGVJbmplY3QoY3NzXzI0OHopO1xuXG5mdW5jdGlvbiBncm91cEJ5V2Vla3MoYWN0aXZpdGllcywgd2Vla1N0YXJ0ID0gMCAvLyAwID0gU3VuZGF5XG4pIHtcbiAgaWYgKGFjdGl2aXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWRBY3Rpdml0aWVzID0gZmlsbEhvbGVzKGFjdGl2aXRpZXMpO1xuXG4gIC8vIERldGVybWluZSB0aGUgZmlyc3QgZGF0ZSBvZiB0aGUgY2FsZW5kYXIuIElmIHRoZSBmaXJzdCBkYXRlIGlzIG5vdCB0aGVcbiAgLy8gc2V0IHN0YXJ0IHdlZWtkYXksIHRoZSBzZWxlY3RlZCB3ZWVrZGF5IG9uZSB3ZWVrIGVhcmxpZXIgaXMgdXNlZC5cbiAgY29uc3QgZmlyc3REYXRlID0gZGF0ZUZucy5wYXJzZUlTTyhub3JtYWxpemVkQWN0aXZpdGllc1swXS5kYXRlKTtcbiAgY29uc3QgZmlyc3RDYWxlbmRhckRhdGUgPSBkYXRlRm5zLmdldERheShmaXJzdERhdGUpID09PSB3ZWVrU3RhcnQgPyBmaXJzdERhdGUgOiBkYXRlRm5zLnN1YldlZWtzKGRhdGVGbnMubmV4dERheShmaXJzdERhdGUsIHdlZWtTdGFydCksIDEpO1xuXG4gIC8vIFRvIGNvcnJlY3RseSBncm91cCBhY3Rpdml0aWVzIGJ5IHdlZWssIGl0IGlzIG5lY2Vzc2FyeSB0byBsZWZ0LXBhZCB0aGUgbGlzdFxuICAvLyBiZWNhdXNlIHRoZSBmaXJzdCBkYXRlIG1pZ2h0IG5vdCBiZSBzZXQgc3RhcnQgd2Vla2RheS5cbiAgY29uc3QgcGFkZGVkQWN0aXZpdGllcyA9IFsuLi5BcnJheShkYXRlRm5zLmRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhmaXJzdERhdGUsIGZpcnN0Q2FsZW5kYXJEYXRlKSkuZmlsbCh1bmRlZmluZWQpLCAuLi5ub3JtYWxpemVkQWN0aXZpdGllc107XG4gIGNvbnN0IG51bWJlck9mV2Vla3MgPSBNYXRoLmNlaWwocGFkZGVkQWN0aXZpdGllcy5sZW5ndGggLyA3KTtcblxuICAvLyBGaW5hbGx5LCBncm91cCBhY3Rpdml0aWVzIGJ5IHdlZWtcbiAgcmV0dXJuIEFycmF5KG51bWJlck9mV2Vla3MpLmZpbGwodW5kZWZpbmVkKS5tYXAoKF8sIHdlZWtJbmRleCkgPT4gcGFkZGVkQWN0aXZpdGllcy5zbGljZSh3ZWVrSW5kZXggKiA3LCB3ZWVrSW5kZXggKiA3ICsgNykpO1xufVxuXG4vKipcbiAqIFRoZSBjYWxlbmRhciBleHBlY3RzIGEgY29udGludW91cyBzZXF1ZW5jZSBvZiBkYXlzLFxuICogc28gZmlsbCBnYXBzIHdpdGggZW1wdHkgYWN0aXZpdHkgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZmlsbEhvbGVzKGFjdGl2aXRpZXMpIHtcbiAgY29uc3QgZGF0ZU1hcCA9IHt9O1xuICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIGFjdGl2aXRpZXMpIHtcbiAgICBkYXRlTWFwW2FjdGl2aXR5LmRhdGVdID0gYWN0aXZpdHk7XG4gIH1cbiAgcmV0dXJuIGRhdGVGbnMuZWFjaERheU9mSW50ZXJ2YWwoe1xuICAgIHN0YXJ0OiBkYXRlRm5zLnBhcnNlSVNPKGFjdGl2aXRpZXNbMF0uZGF0ZSksXG4gICAgZW5kOiBkYXRlRm5zLnBhcnNlSVNPKGFjdGl2aXRpZXNbYWN0aXZpdGllcy5sZW5ndGggLSAxXS5kYXRlKVxuICB9KS5tYXAoZGF5ID0+IHtcbiAgICBjb25zdCBkYXRlID0gZGF0ZUZucy5mb3JtYXRJU08oZGF5LCB7XG4gICAgICByZXByZXNlbnRhdGlvbjogJ2RhdGUnXG4gICAgfSk7XG4gICAgaWYgKGRhdGVNYXBbZGF0ZV0pIHtcbiAgICAgIHJldHVybiBkYXRlTWFwW2RhdGVdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZSxcbiAgICAgIGNvdW50OiAwLFxuICAgICAgbGV2ZWw6IDBcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1vbnRoTGFiZWxzKHdlZWtzLCBtb250aE5hbWVzID0gREVGQVVMVF9NT05USF9MQUJFTFMpIHtcbiAgcmV0dXJuIHdlZWtzLnJlZHVjZSgobGFiZWxzLCB3ZWVrLCB3ZWVrSW5kZXgpID0+IHtcbiAgICBjb25zdCBmaXJzdEFjdGl2aXR5ID0gd2Vlay5maW5kKGFjdGl2aXR5ID0+IGFjdGl2aXR5ICE9PSB1bmRlZmluZWQpO1xuICAgIGlmICghZmlyc3RBY3Rpdml0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVycm9yOiBXZWVrICR7d2Vla0luZGV4ICsgMX0gaXMgZW1wdHk6IFske3dlZWt9XS5gKTtcbiAgICB9XG4gICAgY29uc3QgbW9udGggPSBtb250aE5hbWVzW2RhdGVGbnMuZ2V0TW9udGgoZGF0ZUZucy5wYXJzZUlTTyhmaXJzdEFjdGl2aXR5LmRhdGUpKV07XG4gICAgY29uc3QgcHJldkxhYmVsID0gbGFiZWxzW2xhYmVscy5sZW5ndGggLSAxXTtcbiAgICBpZiAod2Vla0luZGV4ID09PSAwIHx8IHByZXZMYWJlbC5sYWJlbCAhPT0gbW9udGgpIHtcbiAgICAgIHJldHVybiBbLi4ubGFiZWxzLCB7XG4gICAgICAgIHdlZWtJbmRleCxcbiAgICAgICAgbGFiZWw6IG1vbnRoXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVscztcbiAgfSwgW10pLmZpbHRlcigoe1xuICAgIHdlZWtJbmRleFxuICB9LCBpbmRleCwgbGFiZWxzKSA9PiB7XG4gICAgLy8gTGFiZWxzIHNob3VsZCBvbmx5IGJlIHNob3duIGlmIHRoZXJlIGlzIFwiZW5vdWdoXCIgc3BhY2UgKGRhdGEpLlxuICAgIC8vIFRoaXMgaXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXMgbm90IHRha2UgdGhlIGJsb2NrIHNpemUsXG4gICAgLy8gZm9udCBzaXplIGV0Yy4gaW50byBhY2NvdW50LlxuICAgIGNvbnN0IG1pbldlZWtzID0gMztcblxuICAgIC8vIFNraXAgdGhlIGZpcnN0IG1vbnRoIGxhYmVsIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgdG8gdGhlIG5leHQgb25lLlxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGxhYmVsc1sxXSAmJiBsYWJlbHNbMV0ud2Vla0luZGV4IC0gd2Vla0luZGV4ID49IG1pbldlZWtzO1xuICAgIH1cblxuICAgIC8vIFNraXAgdGhlIGxhc3QgbW9udGggbGFiZWwgdGhlIHRoZXJlIGlzIG5vdCBlbm91Z2ggZGF0YSBpbiB0aGF0IG1vbnRoIHRvXG4gICAgLy8gYXZvaWQgb3ZlcmZsb3dpbmcgdGhlIGNhbGVuZGFyIG9uIHRoZSByaWdodC5cbiAgICBpZiAoaW5kZXggPT09IGxhYmVscy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gd2Vla3Muc2xpY2Uod2Vla0luZGV4KS5sZW5ndGggPj0gbWluV2Vla3M7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShuYW1lLCBzdHlsZXMpIHtcbiAgaWYgKHN0eWxlcykge1xuICAgIHJldHVybiBgJHtOQU1FU1BBQ0V9X18ke25hbWV9ICR7c3R5bGVzfWA7XG4gIH1cbiAgcmV0dXJuIGAke05BTUVTUEFDRX1fXyR7bmFtZX1gO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFbXB0eURhdGEoKSB7XG4gIGNvbnN0IHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IGRheXMgPSBkYXRlRm5zLmVhY2hEYXlPZkludGVydmFsKHtcbiAgICBzdGFydDogbmV3IERhdGUoeWVhciwgMCwgMSksXG4gICAgZW5kOiBuZXcgRGF0ZSh5ZWFyLCAxMSwgMzEpXG4gIH0pO1xuICByZXR1cm4gZGF5cy5tYXAoZGF0ZSA9PiAoe1xuICAgIGRhdGU6IGRhdGVGbnMuZm9ybWF0SVNPKGRhdGUsIHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiAnZGF0ZSdcbiAgICB9KSxcbiAgICBjb3VudDogMCxcbiAgICBsZXZlbDogMFxuICB9KSk7XG59XG5mdW5jdGlvbiBtYXhXZWVrZGF5TGFiZWxMZW5ndGgoZmlyc3RXZWVrLCB3ZWVrU3RhcnQsIGxhYmVscywgZm9udFNpemUpIHtcbiAgcmV0dXJuIGZpcnN0V2Vlay5yZWR1Y2UoKG1heExlbmd0aCwgXywgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggJSAyICE9PSAwKSB7XG4gICAgICBjb25zdCBkYXlJbmRleCA9IChpbmRleCArIHdlZWtTdGFydCkgJSA3O1xuICAgICAgY29uc3QgY3VyTGVuZ3RoID0gTWF0aC5jZWlsKGNhbGNUZXh0RGltZW5zaW9ucyhsYWJlbHNbZGF5SW5kZXhdLCBmb250U2l6ZSkud2lkdGgpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1heExlbmd0aCwgY3VyTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heExlbmd0aDtcbiAgfSwgMCk7XG59XG5mdW5jdGlvbiBjYWxjVGV4dERpbWVuc2lvbnModGV4dCwgZm9udFNpemUpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGNUZXh0RGltZW5zaW9ucygpIHJlcXVpcmVzIGJyb3dzZXIgQVBJcycpO1xuICB9XG4gIGlmIChmb250U2l6ZSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZm9udFNpemUgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICB9XG4gIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gIH1cbiAgY29uc3QgbmFtZXNwYWNlID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgJ3N2ZycpO1xuICBzdmcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBzdmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBzdmcuc3R5bGUuZm9udEZhbWlseSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLmZvbnRGYW1pbHk7XG4gIHN2Zy5zdHlsZS5mb250U2l6ZSA9IGAke2ZvbnRTaXplfXB4YDtcbiAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAndGV4dCcpO1xuICB0ZXh0Tm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgY29uc3QgYm91bmRpbmdCb3ggPSB0ZXh0Tm9kZS5nZXRCQm94KCk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3ZnKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogYm91bmRpbmdCb3gud2lkdGgsXG4gICAgaGVpZ2h0OiBib3VuZGluZ0JveC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGhlbWUoaW5wdXQsIHNpemUgPSA1KSB7XG4gIGNvbnN0IGRlZmF1bHRUaGVtZSA9IGNyZWF0ZURlZmF1bHRUaGVtZShzaXplKTtcbiAgaWYgKGlucHV0KSB7XG4gICAgdmFsaWRhdGVUaGVtZShpbnB1dCwgc2l6ZSk7XG4gICAgaW5wdXQubGlnaHQgPSBpbnB1dC5saWdodCA/PyBkZWZhdWx0VGhlbWUubGlnaHQ7XG4gICAgaW5wdXQuZGFyayA9IGlucHV0LmRhcmsgPz8gZGVmYXVsdFRoZW1lLmRhcms7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpZ2h0OiBpc0NvbG9yU2NhbGUoaW5wdXQubGlnaHQsIHNpemUpID8gaW5wdXQubGlnaHQgOiBjcmVhdGVDb2xvclNjYWxlKGlucHV0LmxpZ2h0LCBzaXplKSxcbiAgICAgIGRhcms6IGlzQ29sb3JTY2FsZShpbnB1dC5kYXJrLCBzaXplKSA/IGlucHV0LmRhcmsgOiBjcmVhdGVDb2xvclNjYWxlKGlucHV0LmRhcmssIHNpemUpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFRoZW1lO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFRoZW1lKHNpemUpIHtcbiAgcmV0dXJuIHtcbiAgICBsaWdodDogY3JlYXRlQ29sb3JTY2FsZShbJ2hzbCgwLCAwJSwgOTIlKScsICdoc2woMCwgMCUsIDI2JSknXSwgc2l6ZSksXG4gICAgZGFyazogY3JlYXRlQ29sb3JTY2FsZShbJ2hzbCgwLCAwJSwgMjAlKScsICdoc2woMCwgMCUsIDkyJSknXSwgc2l6ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVGhlbWUoaW5wdXQsIHNpemUpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgaW5wdXQubGlnaHQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dC5kYXJrID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB0aGVtZSBvYmplY3QgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB0aGUgZmllbGRzIFwibGlnaHRcIiBhbmQgXCJkYXJrXCIgd2l0aCBleGFjdGx5IDIgb3IgJHtzaXplfSBjb2xvcnMgcmVzcGVjdGl2ZWx5LmApO1xuICB9XG4gIGlmIChpbnB1dC5saWdodCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBpbnB1dC5saWdodDtcbiAgICBpZiAobGVuZ3RoICE9PSAyICYmIGxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aGVtZS5saWdodCBtdXN0IGNvbnRhaW4gZXhhY3RseSAyIG9yICR7c2l6ZX0gY29sb3JzLCAke2xlbmd0aH0gcGFzc2VkLmApO1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQuZGFyaykge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBpbnB1dC5kYXJrO1xuICAgIGlmIChsZW5ndGggIT09IDIgJiYgbGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRoZW1lLmRhcmsgbXVzdCBjb250YWluIGV4YWN0bHkgMiBvciAke3NpemV9IGNvbG9ycywgJHtsZW5ndGh9IHBhc3NlZC5gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29sb3JTY2FsZShjb2xvcnMsIHNpemUpIHtcbiAgY29uc3QgaW52YWxpZENvbG9yID0gY29sb3JzLmZpbmQoY29sb3IgPT4gIWNocm9tYV9fZGVmYXVsdC5kZWZhdWx0LnZhbGlkKGNvbG9yKSk7XG4gIGlmIChpbnZhbGlkQ29sb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29sb3IgXCIke2ludmFsaWRDb2xvcn1cIiBwYXNzZWQuIEFsbCBDU1MgY29sb3IgZm9ybWF0cyBhcmUgYWNjZXB0ZWQuYCk7XG4gIH1cbiAgcmV0dXJuIGNvbG9ycy5sZW5ndGggPT09IHNpemU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb2xvclNjYWxlKGNvbG9ycywgc2l6ZSkge1xuICByZXR1cm4gY2hyb21hX19kZWZhdWx0LmRlZmF1bHQuc2NhbGUoY29sb3JzKS5tb2RlKCdsY2gnKS5jb2xvcnMoc2l6ZSk7XG59XG5cbmNvbnN0IEFjdGl2aXR5Q2FsZW5kYXIgPSAoe1xuICBkYXRhLFxuICBibG9ja01hcmdpbiA9IDQsXG4gIGJsb2NrUmFkaXVzID0gMixcbiAgYmxvY2tTaXplID0gMTIsXG4gIGNvbG9yU2NoZW1lID0gdW5kZWZpbmVkLFxuICBldmVudEhhbmRsZXJzID0ge30sXG4gIGZvbnRTaXplID0gMTQsXG4gIGhpZGVDb2xvckxlZ2VuZCA9IGZhbHNlLFxuICBoaWRlTW9udGhMYWJlbHMgPSBmYWxzZSxcbiAgaGlkZVRvdGFsQ291bnQgPSBmYWxzZSxcbiAgbGFiZWxzOiBsYWJlbHNQcm9wID0gdW5kZWZpbmVkLFxuICBtYXhMZXZlbCA9IDQsXG4gIGxvYWRpbmcgPSBmYWxzZSxcbiAgcmVuZGVyQmxvY2sgPSB1bmRlZmluZWQsXG4gIHNob3dXZWVrZGF5TGFiZWxzID0gZmFsc2UsXG4gIHN0eWxlOiBzdHlsZVByb3AgPSB7fSxcbiAgdGhlbWU6IHRoZW1lUHJvcCA9IHVuZGVmaW5lZCxcbiAgdG90YWxDb3VudDogdG90YWxDb3VudFByb3AgPSB1bmRlZmluZWQsXG4gIHdlZWtTdGFydCA9IDAgLy8gU3VuZGF5XG59KSA9PiB7XG4gIG1heExldmVsID0gTWF0aC5tYXgoMSwgbWF4TGV2ZWwpO1xuICBjb25zdCB0aGVtZSA9IGNyZWF0ZVRoZW1lKHRoZW1lUHJvcCwgbWF4TGV2ZWwgKyAxKTtcbiAgY29uc3Qgc3lzdGVtQ29sb3JTY2hlbWUgPSB1c2VDb2xvclNjaGVtZSgpO1xuICBjb25zdCBjb2xvclNjYWxlID0gdGhlbWVbY29sb3JTY2hlbWUgPz8gc3lzdGVtQ29sb3JTY2hlbWVdO1xuICBjb25zdCB1c2VBbmltYXRpb24gPSAhdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24oKTtcbiAgaWYgKGxvYWRpbmcpIHtcbiAgICBkYXRhID0gZ2VuZXJhdGVFbXB0eURhdGEoKTtcbiAgfVxuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB5ZWFyID0gZGF0ZUZucy5nZXRZZWFyKGRhdGVGbnMucGFyc2VJU08oZGF0YVswXT8uZGF0ZSkpO1xuICBjb25zdCB3ZWVrcyA9IGdyb3VwQnlXZWVrcyhkYXRhLCB3ZWVrU3RhcnQpO1xuICBjb25zdCBsYWJlbHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0xBQkVMUywgbGFiZWxzUHJvcCk7XG4gIGNvbnN0IGxhYmVsSGVpZ2h0ID0gaGlkZU1vbnRoTGFiZWxzID8gMCA6IGZvbnRTaXplICsgTEFCRUxfTUFSR0lOO1xuICBjb25zdCB3ZWVrZGF5TGFiZWxPZmZzZXQgPSBzaG93V2Vla2RheUxhYmVscyA/IG1heFdlZWtkYXlMYWJlbExlbmd0aCh3ZWVrc1swXSwgd2Vla1N0YXJ0LCBsYWJlbHMud2Vla2RheXMsIGZvbnRTaXplKSArIExBQkVMX01BUkdJTiA6IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdlZWtzLmxlbmd0aCAqIChibG9ja1NpemUgKyBibG9ja01hcmdpbikgLSBibG9ja01hcmdpbixcbiAgICAgIGhlaWdodDogbGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogNyAtIGJsb2NrTWFyZ2luXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRFdmVudEhhbmRsZXJzKGFjdGl2aXR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGV2ZW50SGFuZGxlcnMpLnJlZHVjZSgoaGFuZGxlcnMsIGtleSkgPT4gKHtcbiAgICAgIC4uLmhhbmRsZXJzLFxuICAgICAgW2tleV06IGV2ZW50ID0+IGV2ZW50SGFuZGxlcnNba2V5XT8uKGV2ZW50KShhY3Rpdml0eSlcbiAgICB9KSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckNhbGVuZGFyKCkge1xuICAgIHJldHVybiB3ZWVrcy5tYXAoKHdlZWssIHdlZWtJbmRleCkgPT4gd2Vlay5tYXAoKGFjdGl2aXR5LCBkYXlJbmRleCkgPT4ge1xuICAgICAgaWYgKCFhY3Rpdml0eSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpdml0eS5sZXZlbCA8IDAgfHwgYWN0aXZpdHkubGV2ZWwgPiBtYXhMZXZlbCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUHJvdmlkZWQgYWN0aXZpdHkgbGV2ZWwgJHthY3Rpdml0eS5sZXZlbH0gZm9yICR7YWN0aXZpdHkuZGF0ZX0gaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHttYXhMZXZlbH0uYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHlsZSA9IGxvYWRpbmcgJiYgdXNlQW5pbWF0aW9uID8ge1xuICAgICAgICBhbmltYXRpb246IGAke3N0eWxlcy5sb2FkaW5nQW5pbWF0aW9ufSAxLjc1cyBlYXNlLWluLW91dCBpbmZpbml0ZWAsXG4gICAgICAgIGFuaW1hdGlvbkRlbGF5OiBgJHt3ZWVrSW5kZXggKiAyMCArIGRheUluZGV4ICogMjB9bXNgXG4gICAgICB9IDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgYmxvY2sgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCBfZXh0ZW5kcyh7fSwgZ2V0RXZlbnRIYW5kbGVycyhhY3Rpdml0eSksIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogbGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogZGF5SW5kZXgsXG4gICAgICAgIHdpZHRoOiBibG9ja1NpemUsXG4gICAgICAgIGhlaWdodDogYmxvY2tTaXplLFxuICAgICAgICByeDogYmxvY2tSYWRpdXMsXG4gICAgICAgIHJ5OiBibG9ja1JhZGl1cyxcbiAgICAgICAgZmlsbDogY29sb3JTY2FsZVthY3Rpdml0eS5sZXZlbF0sXG4gICAgICAgIFwiZGF0YS1kYXRlXCI6IGFjdGl2aXR5LmRhdGUsXG4gICAgICAgIFwiZGF0YS1sZXZlbFwiOiBhY3Rpdml0eS5sZXZlbCxcbiAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwge1xuICAgICAgICBrZXk6IGFjdGl2aXR5LmRhdGVcbiAgICAgIH0sIHJlbmRlckJsb2NrID8gcmVuZGVyQmxvY2soYmxvY2ssIGFjdGl2aXR5KSA6IGJsb2NrKTtcbiAgICB9KSkubWFwKCh3ZWVrLCB4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICBrZXk6IHgsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHsoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogeH0sIDApYFxuICAgIH0sIHdlZWspKTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJGb290ZXIoKSB7XG4gICAgaWYgKGhpZGVUb3RhbENvdW50ICYmIGhpZGVDb2xvckxlZ2VuZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsQ291bnQgPSB0eXBlb2YgdG90YWxDb3VudFByb3AgPT09ICdudW1iZXInID8gdG90YWxDb3VudFByb3AgOiBkYXRhLnJlZHVjZSgoc3VtLCBhY3Rpdml0eSkgPT4gc3VtICsgYWN0aXZpdHkuY291bnQsIDApO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZm9vdGVyXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKCdmb290ZXInLCBzdHlsZXMuZm9vdGVyKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IHdlZWtkYXlMYWJlbE9mZnNldFxuICAgICAgfVxuICAgIH0sIGxvYWRpbmcgJiYgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcIlxceEEwXCIpLCAhbG9hZGluZyAmJiAhaGlkZVRvdGFsQ291bnQgJiYgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IGdldENsYXNzTmFtZSgnY291bnQnKVxuICAgIH0sIGxhYmVscy50b3RhbENvdW50ID8gbGFiZWxzLnRvdGFsQ291bnQucmVwbGFjZSgne3tjb3VudH19JywgU3RyaW5nKHRvdGFsQ291bnQpKS5yZXBsYWNlKCd7e3llYXJ9fScsIFN0cmluZyh5ZWFyKSkgOiBgJHt0b3RhbENvdW50fSBhY3Rpdml0aWVzIGluICR7eWVhcn1gKSwgIWxvYWRpbmcgJiYgIWhpZGVDb2xvckxlZ2VuZCAmJiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKCdsZWdlbmQtY29sb3JzJywgc3R5bGVzLmxlZ2VuZENvbG9ycylcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBtYXJnaW5SaWdodDogJzAuNGVtJ1xuICAgICAgfVxuICAgIH0sIGxhYmVscz8ubGVnZW5kPy5sZXNzID8/ICdMZXNzJyksIEFycmF5KG1heExldmVsICsgMSkuZmlsbCh1bmRlZmluZWQpLm1hcCgoXywgbGV2ZWwpID0+IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgICAgd2lkdGg6IGJsb2NrU2l6ZSxcbiAgICAgIGhlaWdodDogYmxvY2tTaXplLFxuICAgICAga2V5OiBsZXZlbFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgIHdpZHRoOiBibG9ja1NpemUsXG4gICAgICBoZWlnaHQ6IGJsb2NrU2l6ZSxcbiAgICAgIGZpbGw6IGNvbG9yU2NhbGVbbGV2ZWxdLFxuICAgICAgcng6IGJsb2NrUmFkaXVzLFxuICAgICAgcnk6IGJsb2NrUmFkaXVzXG4gICAgfSkpKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogJzAuNGVtJ1xuICAgICAgfVxuICAgIH0sIGxhYmVscz8ubGVnZW5kPy5tb3JlID8/ICdNb3JlJykpKTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMYWJlbHMoKSB7XG4gICAgaWYgKCFzaG93V2Vla2RheUxhYmVscyAmJiBoaWRlTW9udGhMYWJlbHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBzaG93V2Vla2RheUxhYmVscyAmJiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICBjbGFzc05hbWU6IGdldENsYXNzTmFtZSgnbGVnZW5kLXdlZWtkYXknKVxuICAgIH0sIHdlZWtzWzBdLm1hcCgoXywgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXlJbmRleCA9IChpbmRleCArIHdlZWtTdGFydCkgJSA3O1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIHtcbiAgICAgICAgeDogLUxBQkVMX01BUkdJTixcbiAgICAgICAgeTogbGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogaW5kZXggKyBibG9ja1NpemUgLyAyLFxuICAgICAgICBkb21pbmFudEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICAgICAgICB0ZXh0QW5jaG9yOiBcImVuZFwiLFxuICAgICAgICBrZXk6IGluZGV4XG4gICAgICB9LCBsYWJlbHMud2Vla2RheXNbZGF5SW5kZXhdKTtcbiAgICB9KSksICFoaWRlTW9udGhMYWJlbHMgJiYgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgY2xhc3NOYW1lOiBnZXRDbGFzc05hbWUoJ2xlZ2VuZC1tb250aCcpXG4gICAgfSwgZ2V0TW9udGhMYWJlbHMod2Vla3MsIGxhYmVscy5tb250aHMpLm1hcCgoe1xuICAgICAgbGFiZWwsXG4gICAgICB3ZWVrSW5kZXhcbiAgICB9KSA9PiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCB7XG4gICAgICB4OiAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogd2Vla0luZGV4LFxuICAgICAgZG9taW5hbnRCYXNlbGluZTogXCJoYW5naW5nXCIsXG4gICAgICBrZXk6IHdlZWtJbmRleFxuICAgIH0sIGxhYmVsKSkpKTtcbiAgfVxuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBnZXREaW1lbnNpb25zKCk7XG4gIGNvbnN0IGNvbnRhaW5lclN0eWxlcyA9IHtcbiAgICBmb250U2l6ZSxcbiAgICAuLi4odXNlQW5pbWF0aW9uICYmIHtcbiAgICAgIFtgLS0ke05BTUVTUEFDRX0tbG9hZGluZ2BdOiBjb2xvclNjYWxlWzBdLFxuICAgICAgW2AtLSR7TkFNRVNQQUNFfS1sb2FkaW5nLWFjdGl2ZWBdOiBjb2xvclNjaGVtZSA9PT0gJ2xpZ2h0JyA/IGNocm9tYV9fZGVmYXVsdC5kZWZhdWx0KGNvbG9yU2NhbGVbMF0pLmRhcmtlbigwLjMpLmhleCgpIDogY2hyb21hX19kZWZhdWx0LmRlZmF1bHQoY29sb3JTY2FsZVswXSkuYnJpZ2h0ZW4oMC4yNSkuaGV4KClcbiAgICB9KVxuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFydGljbGVcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7TkFNRVNQQUNFfSAke3N0eWxlcy5jb250YWluZXJ9YCxcbiAgICBzdHlsZToge1xuICAgICAgLi4uc3R5bGVQcm9wLFxuICAgICAgLi4uY29udGFpbmVyU3R5bGVzXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGdldENsYXNzTmFtZSgnc2Nyb2xsLWNvbnRhaW5lcicsIHN0eWxlcy5zY3JvbGxDb250YWluZXIpXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB2aWV3Qm94OiBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWAsXG4gICAgY2xhc3NOYW1lOiBnZXRDbGFzc05hbWUoJ2NhbGVuZGFyJywgc3R5bGVzLmNhbGVuZGFyKSxcbiAgICBzdHlsZToge1xuICAgICAgbWFyZ2luTGVmdDogd2Vla2RheUxhYmVsT2Zmc2V0XG4gICAgfVxuICB9LCAhbG9hZGluZyAmJiByZW5kZXJMYWJlbHMoKSwgcmVuZGVyQ2FsZW5kYXIoKSkpLCByZW5kZXJGb290ZXIoKSk7XG59O1xuY29uc3QgU2tlbGV0b24gPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFjdGl2aXR5Q2FsZW5kYXIsIF9leHRlbmRzKHtcbiAgZGF0YTogW11cbn0sIHByb3BzKSk7XG5cbmV4cG9ydHMuU2tlbGV0b24gPSBTa2VsZXRvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFjdGl2aXR5Q2FsZW5kYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNocm9tYSIsInJlcXVpcmUiLCJkYXRlRm5zIiwiUmVhY3QiLCJfaW50ZXJvcERlZmF1bHQiLCJlIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjaHJvbWFfX2RlZmF1bHQiLCJSZWFjdF9fZGVmYXVsdCIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIk5BTUVTUEFDRSIsIkxBQkVMX01BUkdJTiIsIkRFRkFVTFRfTU9OVEhfTEFCRUxTIiwiREVGQVVMVF9MQUJFTFMiLCJtb250aHMiLCJ3ZWVrZGF5cyIsInRvdGFsQ291bnQiLCJsZWdlbmQiLCJsZXNzIiwibW9yZSIsInVzZUNvbG9yU2NoZW1lIiwiY29sb3JTY2hlbWUiLCJzZXRDb2xvclNjaGVtZSIsInVzZVN0YXRlIiwib25DaGFuZ2UiLCJldmVudCIsIm1hdGNoZXMiLCJ1c2VFZmZlY3QiLCJtZWRpYVF1ZXJ5Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicXVlcnkiLCJ1c2VQcmVmZXJzUmVkdWNlZE1vdGlvbiIsInByZWZlcnNSZWR1Y2VkTW90aW9uIiwic2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJzdHlsZUluamVjdCIsImNzcyIsInJlZiIsImluc2VydEF0IiwiZG9jdW1lbnQiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZSIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiZmlyc3RDaGlsZCIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwic3R5bGVTaGVldCIsImNzc1RleHQiLCJjcmVhdGVUZXh0Tm9kZSIsImNzc18yNDh6Iiwic3R5bGVzIiwiZ3JvdXBCeVdlZWtzIiwiYWN0aXZpdGllcyIsIndlZWtTdGFydCIsIm5vcm1hbGl6ZWRBY3Rpdml0aWVzIiwiZmlsbEhvbGVzIiwiZmlyc3REYXRlIiwicGFyc2VJU08iLCJkYXRlIiwiZmlyc3RDYWxlbmRhckRhdGUiLCJnZXREYXkiLCJzdWJXZWVrcyIsIm5leHREYXkiLCJwYWRkZWRBY3Rpdml0aWVzIiwiQXJyYXkiLCJkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMiLCJmaWxsIiwidW5kZWZpbmVkIiwibnVtYmVyT2ZXZWVrcyIsIk1hdGgiLCJjZWlsIiwibWFwIiwiXyIsIndlZWtJbmRleCIsInNsaWNlIiwiZGF0ZU1hcCIsImFjdGl2aXR5IiwiZWFjaERheU9mSW50ZXJ2YWwiLCJzdGFydCIsImVuZCIsImRheSIsImZvcm1hdElTTyIsInJlcHJlc2VudGF0aW9uIiwiY291bnQiLCJsZXZlbCIsImdldE1vbnRoTGFiZWxzIiwid2Vla3MiLCJtb250aE5hbWVzIiwicmVkdWNlIiwibGFiZWxzIiwid2VlayIsImZpcnN0QWN0aXZpdHkiLCJmaW5kIiwiRXJyb3IiLCJtb250aCIsImdldE1vbnRoIiwicHJldkxhYmVsIiwibGFiZWwiLCJmaWx0ZXIiLCJpbmRleCIsIm1pbldlZWtzIiwiZ2V0Q2xhc3NOYW1lIiwibmFtZSIsImdlbmVyYXRlRW1wdHlEYXRhIiwieWVhciIsIkRhdGUiLCJnZXRGdWxsWWVhciIsImRheXMiLCJtYXhXZWVrZGF5TGFiZWxMZW5ndGgiLCJmaXJzdFdlZWsiLCJmb250U2l6ZSIsIm1heExlbmd0aCIsImRheUluZGV4IiwiY3VyTGVuZ3RoIiwiY2FsY1RleHREaW1lbnNpb25zIiwid2lkdGgiLCJtYXgiLCJ0ZXh0IiwiUmFuZ2VFcnJvciIsImhlaWdodCIsIm5hbWVzcGFjZSIsInN2ZyIsImNyZWF0ZUVsZW1lbnROUyIsInBvc2l0aW9uIiwidmlzaWJpbGl0eSIsImZvbnRGYW1pbHkiLCJnZXRDb21wdXRlZFN0eWxlIiwiYm9keSIsInRleHROb2RlIiwidGV4dENvbnRlbnQiLCJib3VuZGluZ0JveCIsImdldEJCb3giLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVRoZW1lIiwiaW5wdXQiLCJzaXplIiwiZGVmYXVsdFRoZW1lIiwiY3JlYXRlRGVmYXVsdFRoZW1lIiwidmFsaWRhdGVUaGVtZSIsImxpZ2h0IiwiZGFyayIsImlzQ29sb3JTY2FsZSIsImNyZWF0ZUNvbG9yU2NhbGUiLCJjb2xvcnMiLCJpbnZhbGlkQ29sb3IiLCJjb2xvciIsInZhbGlkIiwic2NhbGUiLCJtb2RlIiwiQWN0aXZpdHlDYWxlbmRhciIsImRhdGEiLCJibG9ja01hcmdpbiIsImJsb2NrUmFkaXVzIiwiYmxvY2tTaXplIiwiZXZlbnRIYW5kbGVycyIsImhpZGVDb2xvckxlZ2VuZCIsImhpZGVNb250aExhYmVscyIsImhpZGVUb3RhbENvdW50IiwibGFiZWxzUHJvcCIsIm1heExldmVsIiwibG9hZGluZyIsInJlbmRlckJsb2NrIiwic2hvd1dlZWtkYXlMYWJlbHMiLCJzdHlsZVByb3AiLCJ0aGVtZSIsInRoZW1lUHJvcCIsInRvdGFsQ291bnRQcm9wIiwic3lzdGVtQ29sb3JTY2hlbWUiLCJjb2xvclNjYWxlIiwidXNlQW5pbWF0aW9uIiwiZ2V0WWVhciIsImxhYmVsSGVpZ2h0Iiwid2Vla2RheUxhYmVsT2Zmc2V0IiwiZ2V0RGltZW5zaW9ucyIsImdldEV2ZW50SGFuZGxlcnMiLCJrZXlzIiwiaGFuZGxlcnMiLCJyZW5kZXJDYWxlbmRhciIsImFuaW1hdGlvbiIsImxvYWRpbmdBbmltYXRpb24iLCJhbmltYXRpb25EZWxheSIsImJsb2NrIiwieCIsInkiLCJyeCIsInJ5IiwiRnJhZ21lbnQiLCJ0cmFuc2Zvcm0iLCJyZW5kZXJGb290ZXIiLCJzdW0iLCJjbGFzc05hbWUiLCJmb290ZXIiLCJtYXJnaW5MZWZ0IiwicmVwbGFjZSIsIlN0cmluZyIsImxlZ2VuZENvbG9ycyIsIm1hcmdpblJpZ2h0IiwicmVuZGVyTGFiZWxzIiwiZG9taW5hbnRCYXNlbGluZSIsInRleHRBbmNob3IiLCJjb250YWluZXJTdHlsZXMiLCJkYXJrZW4iLCJoZXgiLCJicmlnaHRlbiIsImNvbnRhaW5lciIsInNjcm9sbENvbnRhaW5lciIsInZpZXdCb3giLCJjYWxlbmRhciIsIlNrZWxldG9uIiwicHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/react-activity-calendar/build/index.js\n");

/***/ })

};
;