"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@anatine";
exports.ids = ["vendor-chunks/@anatine"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@anatine/zod-openapi/src/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/@anatine/zod-openapi/src/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./lib/zod-openapi */ \"(ssr)/../../node_modules/@anatine/zod-openapi/src/lib/zod-openapi.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lib/zod-extensions */ \"(ssr)/../../node_modules/@anatine/zod-openapi/src/lib/zod-extensions.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbmF0aW5lL3pvZC1vcGVuYXBpL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsK0ZBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxxR0FBc0I7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BhbmF0aW5lL3pvZC1vcGVuYXBpL3NyYy9pbmRleC5qcz82ZTZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL3pvZC1vcGVuYXBpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvem9kLWV4dGVuc2lvbnNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@anatine/zod-openapi/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@anatine/zod-openapi/src/lib/zod-extensions.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@anatine/zod-openapi/src/lib/zod-extensions.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\nThis code is heavily inspired by https://github.com/asteasolutions/zod-to-openapi/blob/master/src/zod-extensions.ts\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendZodWithOpenApi = void 0;\nconst zod_openapi_1 = __webpack_require__(/*! ./zod-openapi */ \"(ssr)/../../node_modules/@anatine/zod-openapi/src/lib/zod-openapi.js\");\nfunction extendZodWithOpenApi(zod, forceOverride = false) {\n    if (!forceOverride && typeof zod.ZodSchema.prototype.openapi !== 'undefined') {\n        // This zod instance is already extended with the required methods,\n        // doing it again will just result in multiple wrapper methods for\n        // `optional` and `nullable`\n        return;\n    }\n    zod.ZodSchema.prototype.openapi = function (metadata) {\n        return (0, zod_openapi_1.extendApi)(this, metadata);\n    };\n}\nexports.extendZodWithOpenApi = extendZodWithOpenApi;\n//# sourceMappingURL=zod-extensions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbmF0aW5lL3pvZC1vcGVuYXBpL3NyYy9saWIvem9kLWV4dGVuc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLHNCQUFzQixtQkFBTyxDQUFDLDJGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BhbmF0aW5lL3pvZC1vcGVuYXBpL3NyYy9saWIvem9kLWV4dGVuc2lvbnMuanM/ZTg1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGlzIGNvZGUgaXMgaGVhdmlseSBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vYXN0ZWFzb2x1dGlvbnMvem9kLXRvLW9wZW5hcGkvYmxvYi9tYXN0ZXIvc3JjL3pvZC1leHRlbnNpb25zLnRzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kWm9kV2l0aE9wZW5BcGkgPSB2b2lkIDA7XG5jb25zdCB6b2Rfb3BlbmFwaV8xID0gcmVxdWlyZShcIi4vem9kLW9wZW5hcGlcIik7XG5mdW5jdGlvbiBleHRlbmRab2RXaXRoT3BlbkFwaSh6b2QsIGZvcmNlT3ZlcnJpZGUgPSBmYWxzZSkge1xuICAgIGlmICghZm9yY2VPdmVycmlkZSAmJiB0eXBlb2Ygem9kLlpvZFNjaGVtYS5wcm90b3R5cGUub3BlbmFwaSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gVGhpcyB6b2QgaW5zdGFuY2UgaXMgYWxyZWFkeSBleHRlbmRlZCB3aXRoIHRoZSByZXF1aXJlZCBtZXRob2RzLFxuICAgICAgICAvLyBkb2luZyBpdCBhZ2FpbiB3aWxsIGp1c3QgcmVzdWx0IGluIG11bHRpcGxlIHdyYXBwZXIgbWV0aG9kcyBmb3JcbiAgICAgICAgLy8gYG9wdGlvbmFsYCBhbmQgYG51bGxhYmxlYFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHpvZC5ab2RTY2hlbWEucHJvdG90eXBlLm9wZW5hcGkgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuICgwLCB6b2Rfb3BlbmFwaV8xLmV4dGVuZEFwaSkodGhpcywgbWV0YWRhdGEpO1xuICAgIH07XG59XG5leHBvcnRzLmV4dGVuZFpvZFdpdGhPcGVuQXBpID0gZXh0ZW5kWm9kV2l0aE9wZW5BcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16b2QtZXh0ZW5zaW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@anatine/zod-openapi/src/lib/zod-extensions.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@anatine/zod-openapi/src/lib/zod-openapi.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@anatine/zod-openapi/src/lib/zod-openapi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateSchema = exports.extendApi = void 0;\nconst ts_deepmerge_1 = __webpack_require__(/*! ts-deepmerge */ \"(ssr)/../../node_modules/ts-deepmerge/cjs/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/../../node_modules/zod/lib/index.js\");\nfunction extendApi(schema, schemaObject = {}) {\n    const This = schema.constructor;\n    const newSchema = new This(schema._def);\n    newSchema.metaOpenApi = Object.assign({}, schema.metaOpenApi || {}, schemaObject);\n    return newSchema;\n}\nexports.extendApi = extendApi;\nfunction iterateZodObject({ zodRef, useOutput, hideDefinitions, }) {\n    const reduced = Object.keys(zodRef.shape)\n        .filter((key) => (hideDefinitions === null || hideDefinitions === void 0 ? void 0 : hideDefinitions.includes(key)) === false)\n        .reduce((carry, key) => (Object.assign(Object.assign({}, carry), { [key]: generateSchema(zodRef.shape[key], useOutput) })), {});\n    return reduced;\n}\nfunction parseTransformation({ zodRef, schemas, useOutput, }) {\n    const input = generateSchema(zodRef._def.schema, useOutput);\n    let output = 'undefined';\n    if (useOutput && zodRef._def.effect) {\n        const effect = zodRef._def.effect.type === 'transform' ? zodRef._def.effect : null;\n        if (effect && 'transform' in effect) {\n            try {\n                // todo: this doesn't deal with nullable types very well\n                // @ts-expect-error because we try/catch for a missing type\n                const type = input.type[0];\n                output = typeof effect.transform(['integer', 'number'].includes(`${type}`)\n                    ? 0\n                    : 'string' === type\n                        ? ''\n                        : 'boolean' === type\n                            ? false\n                            : 'object' === type\n                                ? {}\n                                : 'null' === type\n                                    ? null\n                                    : 'array' === type\n                                        ? []\n                                        : undefined, { addIssue: () => undefined, path: [] } // TODO: Discover if context is necessary here\n                );\n            }\n            catch (e) {\n                /**/\n            }\n        }\n    }\n    return (0, ts_deepmerge_1.default)(Object.assign(Object.assign(Object.assign({}, (zodRef.description ? { description: zodRef.description } : {})), input), (['number', 'string', 'boolean', 'null'].includes(output)\n        ? {\n            type: [output],\n        }\n        : {})), ...schemas);\n}\nfunction parseString({ zodRef, schemas, }) {\n    const baseSchema = {\n        type: ['string'],\n    };\n    const { checks = [] } = zodRef._def;\n    checks.forEach((item) => {\n        switch (item.kind) {\n            case 'email':\n                baseSchema.format = 'email';\n                break;\n            case 'uuid':\n                baseSchema.format = 'uuid';\n                break;\n            case 'cuid':\n                baseSchema.format = 'cuid';\n                break;\n            case 'url':\n                baseSchema.format = 'uri';\n                break;\n            case 'datetime':\n                baseSchema.format = 'date-time';\n                break;\n            case 'length':\n                baseSchema.minLength = item.value;\n                baseSchema.maxLength = item.value;\n                break;\n            case 'max':\n                baseSchema.maxLength = item.value;\n                break;\n            case 'min':\n                baseSchema.minLength = item.value;\n                break;\n            case 'regex':\n                baseSchema.pattern = item.regex.source;\n                break;\n        }\n    });\n    return (0, ts_deepmerge_1.default)(baseSchema, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseNumber({ zodRef, schemas, }) {\n    const baseSchema = {\n        type: ['number'],\n    };\n    const { checks = [] } = zodRef._def;\n    checks.forEach((item) => {\n        switch (item.kind) {\n            case 'max':\n                if (item.inclusive)\n                    baseSchema.maximum = item.value;\n                else\n                    baseSchema.exclusiveMaximum = item.value;\n                break;\n            case 'min':\n                if (item.inclusive)\n                    baseSchema.minimum = item.value;\n                else\n                    baseSchema.exclusiveMinimum = item.value;\n                break;\n            case 'int':\n                baseSchema.type = ['integer'];\n                break;\n            case 'multipleOf':\n                baseSchema.multipleOf = item.value;\n                break;\n        }\n    });\n    return (0, ts_deepmerge_1.default)(baseSchema, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction getExcludedDefinitionsFromSchema(schemas) {\n    const excludedDefinitions = [];\n    for (const schema of schemas) {\n        if (Array.isArray(schema.hideDefinitions)) {\n            excludedDefinitions.push(...schema.hideDefinitions);\n        }\n    }\n    return excludedDefinitions;\n}\nfunction parseObject({ zodRef, schemas, useOutput, hideDefinitions, }) {\n    var _a;\n    let additionalProperties;\n    // `catchall` obviates `strict`, `strip`, and `passthrough`\n    if (!(zodRef._def.catchall instanceof zod_1.z.ZodNever ||\n        ((_a = zodRef._def.catchall) === null || _a === void 0 ? void 0 : _a._def.typeName) === 'ZodNever'))\n        additionalProperties = generateSchema(zodRef._def.catchall, useOutput);\n    else if (zodRef._def.unknownKeys === 'passthrough')\n        additionalProperties = true;\n    else if (zodRef._def.unknownKeys === 'strict')\n        additionalProperties = false;\n    // So that `undefined` values don't end up in the schema and be weird\n    additionalProperties =\n        additionalProperties != null ? { additionalProperties } : {};\n    const requiredProperties = Object.keys(zodRef.shape).filter((key) => {\n        const item = zodRef.shape[key];\n        return (!(item.isOptional() ||\n            item instanceof zod_1.z.ZodDefault ||\n            item._def.typeName === 'ZodDefault') && !(item instanceof zod_1.z.ZodNever || item._def.typeName === 'ZodDefault'));\n    });\n    const required = requiredProperties.length > 0 ? { required: requiredProperties } : {};\n    return (0, ts_deepmerge_1.default)(Object.assign(Object.assign(Object.assign({ type: ['object'], properties: iterateZodObject({\n            zodRef: zodRef,\n            schemas,\n            useOutput,\n            hideDefinitions: getExcludedDefinitionsFromSchema(schemas),\n        }) }, required), additionalProperties), hideDefinitions), zodRef.description ? { description: zodRef.description, hideDefinitions } : {}, ...schemas);\n}\nfunction parseRecord({ zodRef, schemas, useOutput, }) {\n    return (0, ts_deepmerge_1.default)({\n        type: ['object'],\n        additionalProperties: zodRef._def.valueType instanceof zod_1.z.ZodUnknown\n            ? {}\n            : generateSchema(zodRef._def.valueType, useOutput),\n    }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseBigInt({ zodRef, schemas, }) {\n    return (0, ts_deepmerge_1.default)({ type: ['integer'], format: 'int64' }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseBoolean({ zodRef, schemas, }) {\n    return (0, ts_deepmerge_1.default)({ type: ['boolean'] }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseDate({ zodRef, schemas }) {\n    return (0, ts_deepmerge_1.default)({ type: ['string'], format: 'date-time' }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseNull({ zodRef, schemas }) {\n    return (0, ts_deepmerge_1.default)({\n        type: ['string', 'null'],\n        enum: ['null'],\n    }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseOptional({ schemas, zodRef, useOutput, }) {\n    return (0, ts_deepmerge_1.default)(generateSchema(zodRef.unwrap(), useOutput), zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseNullable({ schemas, zodRef, useOutput, }) {\n    const schema = generateSchema(zodRef.unwrap(), useOutput);\n    return (0, ts_deepmerge_1.default)(schema, { type: ['null'] }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseDefault({ schemas, zodRef, useOutput, }) {\n    return (0, ts_deepmerge_1.default)(Object.assign({ default: zodRef._def.defaultValue() }, generateSchema(zodRef._def.innerType, useOutput)), zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseArray({ schemas, zodRef, useOutput, }) {\n    const constraints = {};\n    if (zodRef._def.exactLength != null) {\n        constraints.minItems = zodRef._def.exactLength.value;\n        constraints.maxItems = zodRef._def.exactLength.value;\n    }\n    if (zodRef._def.minLength != null)\n        constraints.minItems = zodRef._def.minLength.value;\n    if (zodRef._def.maxLength != null)\n        constraints.maxItems = zodRef._def.maxLength.value;\n    return (0, ts_deepmerge_1.default)(Object.assign({ type: ['array'], items: generateSchema(zodRef.element, useOutput) }, constraints), zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseLiteral({ schemas, zodRef, }) {\n    return (0, ts_deepmerge_1.default)({\n        type: [typeof zodRef._def.value],\n        enum: [zodRef._def.value],\n    }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseEnum({ schemas, zodRef, }) {\n    return (0, ts_deepmerge_1.default)({\n        type: [typeof Object.values(zodRef._def.values)[0]],\n        enum: Object.values(zodRef._def.values),\n    }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseIntersection({ schemas, zodRef, useOutput, }) {\n    return (0, ts_deepmerge_1.default)({\n        allOf: [\n            generateSchema(zodRef._def.left, useOutput),\n            generateSchema(zodRef._def.right, useOutput),\n        ],\n    }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseUnion({ schemas, zodRef, useOutput, }) {\n    const contents = zodRef._def.options;\n    if (contents.reduce((prev, content) => prev && content._def.typeName === 'ZodLiteral', true)) {\n        // special case to transform unions of literals into enums\n        const literals = contents;\n        const type = literals.reduce((prev, content) => !prev || prev === typeof content._def.value\n            ? typeof content._def.value\n            : null, null);\n        if (type) {\n            return (0, ts_deepmerge_1.default)({\n                type: [type],\n                enum: literals.map((literal) => literal._def.value),\n            }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n        }\n    }\n    return (0, ts_deepmerge_1.default)({\n        oneOf: contents.map((schema) => generateSchema(schema, useOutput)),\n    }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseDiscriminatedUnion({ schemas, zodRef, useOutput, }) {\n    return (0, ts_deepmerge_1.default)({\n        discriminator: {\n            propertyName: zodRef._def.discriminator,\n        },\n        oneOf: Array.from(zodRef._def.options.values()).map((schema) => generateSchema(schema, useOutput)),\n    }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseNever({ zodRef, schemas, }) {\n    return (0, ts_deepmerge_1.default)({ readOnly: true }, zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parseBranded({ schemas, zodRef, }) {\n    return (0, ts_deepmerge_1.default)(generateSchema(zodRef._def.type), ...schemas);\n}\nfunction catchAllParser({ zodRef, schemas, }) {\n    return (0, ts_deepmerge_1.default)(zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nfunction parsePipeline({ schemas, zodRef, useOutput, }) {\n    return (0, ts_deepmerge_1.default)(generateSchema(useOutput ? zodRef._def.out : zodRef._def.in, useOutput), ...schemas);\n}\nfunction parseReadonly({ zodRef, useOutput, schemas, }) {\n    return (0, ts_deepmerge_1.default)(generateSchema(zodRef._def.innerType, useOutput), zodRef.description ? { description: zodRef.description } : {}, ...schemas);\n}\nconst workerMap = {\n    ZodObject: parseObject,\n    ZodRecord: parseRecord,\n    ZodString: parseString,\n    ZodNumber: parseNumber,\n    ZodBigInt: parseBigInt,\n    ZodBoolean: parseBoolean,\n    ZodDate: parseDate,\n    ZodNull: parseNull,\n    ZodOptional: parseOptional,\n    ZodNullable: parseNullable,\n    ZodDefault: parseDefault,\n    ZodArray: parseArray,\n    ZodLiteral: parseLiteral,\n    ZodEnum: parseEnum,\n    ZodNativeEnum: parseEnum,\n    ZodTransformer: parseTransformation,\n    ZodEffects: parseTransformation,\n    ZodIntersection: parseIntersection,\n    ZodUnion: parseUnion,\n    ZodDiscriminatedUnion: parseDiscriminatedUnion,\n    ZodNever: parseNever,\n    ZodBranded: parseBranded,\n    // TODO Transform the rest to schemas\n    ZodUndefined: catchAllParser,\n    // TODO: `prefixItems` is allowed in OpenAPI 3.1 which can be used to create tuples\n    ZodTuple: catchAllParser,\n    ZodMap: catchAllParser,\n    ZodFunction: catchAllParser,\n    ZodLazy: catchAllParser,\n    ZodPromise: catchAllParser,\n    ZodAny: catchAllParser,\n    ZodUnknown: catchAllParser,\n    ZodVoid: catchAllParser,\n    ZodPipeline: parsePipeline,\n    ZodReadonly: parseReadonly,\n};\nfunction generateSchema(zodRef, useOutput) {\n    const { metaOpenApi = {} } = zodRef;\n    const schemas = [\n        ...(Array.isArray(metaOpenApi) ? metaOpenApi : [metaOpenApi]),\n    ];\n    try {\n        const typeName = zodRef._def.typeName;\n        if (typeName in workerMap) {\n            return workerMap[typeName]({\n                zodRef: zodRef,\n                schemas,\n                useOutput,\n            });\n        }\n        return catchAllParser({ zodRef, schemas });\n    }\n    catch (err) {\n        console.error(err);\n        return catchAllParser({ zodRef, schemas });\n    }\n}\nexports.generateSchema = generateSchema;\n//# sourceMappingURL=zod-openapi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbmF0aW5lL3pvZC1vcGVuYXBpL3NyYy9saWIvem9kLW9wZW5hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsaUJBQWlCO0FBQzFDLHVCQUF1QixtQkFBTyxDQUFDLHdFQUFjO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyxzREFBSztBQUMzQiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQSwrREFBK0QsWUFBWSxxREFBcUQsTUFBTTtBQUN0STtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsS0FBSztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHNDQUFzQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiwwQkFBMEIsa0NBQWtDLElBQUk7QUFDbko7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEVBQTBFLGtDQUFrQyxJQUFJO0FBQ2hIO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxZQUFZ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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AYW5hdGluZS96b2Qtb3BlbmFwaS9zcmMvbGliL3pvZC1vcGVuYXBpLmpzP2M0ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlbmVyYXRlU2NoZW1hID0gZXhwb3J0cy5leHRlbmRBcGkgPSB2b2lkIDA7XG5jb25zdCB0c19kZWVwbWVyZ2VfMSA9IHJlcXVpcmUoXCJ0cy1kZWVwbWVyZ2VcIik7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5mdW5jdGlvbiBleHRlbmRBcGkoc2NoZW1hLCBzY2hlbWFPYmplY3QgPSB7fSkge1xuICAgIGNvbnN0IFRoaXMgPSBzY2hlbWEuY29uc3RydWN0b3I7XG4gICAgY29uc3QgbmV3U2NoZW1hID0gbmV3IFRoaXMoc2NoZW1hLl9kZWYpO1xuICAgIG5ld1NjaGVtYS5tZXRhT3BlbkFwaSA9IE9iamVjdC5hc3NpZ24oe30sIHNjaGVtYS5tZXRhT3BlbkFwaSB8fCB7fSwgc2NoZW1hT2JqZWN0KTtcbiAgICByZXR1cm4gbmV3U2NoZW1hO1xufVxuZXhwb3J0cy5leHRlbmRBcGkgPSBleHRlbmRBcGk7XG5mdW5jdGlvbiBpdGVyYXRlWm9kT2JqZWN0KHsgem9kUmVmLCB1c2VPdXRwdXQsIGhpZGVEZWZpbml0aW9ucywgfSkge1xuICAgIGNvbnN0IHJlZHVjZWQgPSBPYmplY3Qua2V5cyh6b2RSZWYuc2hhcGUpXG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4gKGhpZGVEZWZpbml0aW9ucyA9PT0gbnVsbCB8fCBoaWRlRGVmaW5pdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhpZGVEZWZpbml0aW9ucy5pbmNsdWRlcyhrZXkpKSA9PT0gZmFsc2UpXG4gICAgICAgIC5yZWR1Y2UoKGNhcnJ5LCBrZXkpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhcnJ5KSwgeyBba2V5XTogZ2VuZXJhdGVTY2hlbWEoem9kUmVmLnNoYXBlW2tleV0sIHVzZU91dHB1dCkgfSkpLCB7fSk7XG4gICAgcmV0dXJuIHJlZHVjZWQ7XG59XG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybWF0aW9uKHsgem9kUmVmLCBzY2hlbWFzLCB1c2VPdXRwdXQsIH0pIHtcbiAgICBjb25zdCBpbnB1dCA9IGdlbmVyYXRlU2NoZW1hKHpvZFJlZi5fZGVmLnNjaGVtYSwgdXNlT3V0cHV0KTtcbiAgICBsZXQgb3V0cHV0ID0gJ3VuZGVmaW5lZCc7XG4gICAgaWYgKHVzZU91dHB1dCAmJiB6b2RSZWYuX2RlZi5lZmZlY3QpIHtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gem9kUmVmLl9kZWYuZWZmZWN0LnR5cGUgPT09ICd0cmFuc2Zvcm0nID8gem9kUmVmLl9kZWYuZWZmZWN0IDogbnVsbDtcbiAgICAgICAgaWYgKGVmZmVjdCAmJiAndHJhbnNmb3JtJyBpbiBlZmZlY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbzogdGhpcyBkb2Vzbid0IGRlYWwgd2l0aCBudWxsYWJsZSB0eXBlcyB2ZXJ5IHdlbGxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGJlY2F1c2Ugd2UgdHJ5L2NhdGNoIGZvciBhIG1pc3NpbmcgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBpbnB1dC50eXBlWzBdO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHR5cGVvZiBlZmZlY3QudHJhbnNmb3JtKFsnaW50ZWdlcicsICdudW1iZXInXS5pbmNsdWRlcyhgJHt0eXBlfWApXG4gICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICA6ICdzdHJpbmcnID09PSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdib29sZWFuJyA9PT0gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdvYmplY3QnID09PSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbnVsbCcgPT09IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYXJyYXknID09PSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCB7IGFkZElzc3VlOiAoKSA9PiB1bmRlZmluZWQsIHBhdGg6IFtdIH0gLy8gVE9ETzogRGlzY292ZXIgaWYgY29udGV4dCBpcyBuZWNlc3NhcnkgaGVyZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoem9kUmVmLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogem9kUmVmLmRlc2NyaXB0aW9uIH0gOiB7fSkpLCBpbnB1dCksIChbJ251bWJlcicsICdzdHJpbmcnLCAnYm9vbGVhbicsICdudWxsJ10uaW5jbHVkZXMob3V0cHV0KVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHR5cGU6IFtvdXRwdXRdLFxuICAgICAgICB9XG4gICAgICAgIDoge30pKSwgLi4uc2NoZW1hcyk7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyh7IHpvZFJlZiwgc2NoZW1hcywgfSkge1xuICAgIGNvbnN0IGJhc2VTY2hlbWEgPSB7XG4gICAgICAgIHR5cGU6IFsnc3RyaW5nJ10sXG4gICAgfTtcbiAgICBjb25zdCB7IGNoZWNrcyA9IFtdIH0gPSB6b2RSZWYuX2RlZjtcbiAgICBjaGVja3MuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGl0ZW0ua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgICAgICAgIGJhc2VTY2hlbWEuZm9ybWF0ID0gJ2VtYWlsJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3V1aWQnOlxuICAgICAgICAgICAgICAgIGJhc2VTY2hlbWEuZm9ybWF0ID0gJ3V1aWQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY3VpZCc6XG4gICAgICAgICAgICAgICAgYmFzZVNjaGVtYS5mb3JtYXQgPSAnY3VpZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1cmwnOlxuICAgICAgICAgICAgICAgIGJhc2VTY2hlbWEuZm9ybWF0ID0gJ3VyaSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgICAgICAgYmFzZVNjaGVtYS5mb3JtYXQgPSAnZGF0ZS10aW1lJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlbmd0aCc6XG4gICAgICAgICAgICAgICAgYmFzZVNjaGVtYS5taW5MZW5ndGggPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJhc2VTY2hlbWEubWF4TGVuZ3RoID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgICAgYmFzZVNjaGVtYS5tYXhMZW5ndGggPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgICAgICAgICBiYXNlU2NoZW1hLm1pbkxlbmd0aCA9IGl0ZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWdleCc6XG4gICAgICAgICAgICAgICAgYmFzZVNjaGVtYS5wYXR0ZXJuID0gaXRlbS5yZWdleC5zb3VyY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKGJhc2VTY2hlbWEsIHpvZFJlZi5kZXNjcmlwdGlvbiA/IHsgZGVzY3JpcHRpb246IHpvZFJlZi5kZXNjcmlwdGlvbiB9IDoge30sIC4uLnNjaGVtYXMpO1xufVxuZnVuY3Rpb24gcGFyc2VOdW1iZXIoeyB6b2RSZWYsIHNjaGVtYXMsIH0pIHtcbiAgICBjb25zdCBiYXNlU2NoZW1hID0ge1xuICAgICAgICB0eXBlOiBbJ251bWJlciddLFxuICAgIH07XG4gICAgY29uc3QgeyBjaGVja3MgPSBbXSB9ID0gem9kUmVmLl9kZWY7XG4gICAgY2hlY2tzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgc3dpdGNoIChpdGVtLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaW5jbHVzaXZlKVxuICAgICAgICAgICAgICAgICAgICBiYXNlU2NoZW1hLm1heGltdW0gPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYmFzZVNjaGVtYS5leGNsdXNpdmVNYXhpbXVtID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaW5jbHVzaXZlKVxuICAgICAgICAgICAgICAgICAgICBiYXNlU2NoZW1hLm1pbmltdW0gPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYmFzZVNjaGVtYS5leGNsdXNpdmVNaW5pbXVtID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ludCc6XG4gICAgICAgICAgICAgICAgYmFzZVNjaGVtYS50eXBlID0gWydpbnRlZ2VyJ107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtdWx0aXBsZU9mJzpcbiAgICAgICAgICAgICAgICBiYXNlU2NoZW1hLm11bHRpcGxlT2YgPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCB0c19kZWVwbWVyZ2VfMS5kZWZhdWx0KShiYXNlU2NoZW1hLCB6b2RSZWYuZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uOiB6b2RSZWYuZGVzY3JpcHRpb24gfSA6IHt9LCAuLi5zY2hlbWFzKTtcbn1cbmZ1bmN0aW9uIGdldEV4Y2x1ZGVkRGVmaW5pdGlvbnNGcm9tU2NoZW1hKHNjaGVtYXMpIHtcbiAgICBjb25zdCBleGNsdWRlZERlZmluaXRpb25zID0gW107XG4gICAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaGlkZURlZmluaXRpb25zKSkge1xuICAgICAgICAgICAgZXhjbHVkZWREZWZpbml0aW9ucy5wdXNoKC4uLnNjaGVtYS5oaWRlRGVmaW5pdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleGNsdWRlZERlZmluaXRpb25zO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3QoeyB6b2RSZWYsIHNjaGVtYXMsIHVzZU91dHB1dCwgaGlkZURlZmluaXRpb25zLCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBhZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAvLyBgY2F0Y2hhbGxgIG9idmlhdGVzIGBzdHJpY3RgLCBgc3RyaXBgLCBhbmQgYHBhc3N0aHJvdWdoYFxuICAgIGlmICghKHpvZFJlZi5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2Ygem9kXzEuei5ab2ROZXZlciB8fFxuICAgICAgICAoKF9hID0gem9kUmVmLl9kZWYuY2F0Y2hhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fZGVmLnR5cGVOYW1lKSA9PT0gJ1pvZE5ldmVyJykpXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gZ2VuZXJhdGVTY2hlbWEoem9kUmVmLl9kZWYuY2F0Y2hhbGwsIHVzZU91dHB1dCk7XG4gICAgZWxzZSBpZiAoem9kUmVmLl9kZWYudW5rbm93bktleXMgPT09ICdwYXNzdGhyb3VnaCcpXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gdHJ1ZTtcbiAgICBlbHNlIGlmICh6b2RSZWYuX2RlZi51bmtub3duS2V5cyA9PT0gJ3N0cmljdCcpXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gZmFsc2U7XG4gICAgLy8gU28gdGhhdCBgdW5kZWZpbmVkYCB2YWx1ZXMgZG9uJ3QgZW5kIHVwIGluIHRoZSBzY2hlbWEgYW5kIGJlIHdlaXJkXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPVxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyAhPSBudWxsID8geyBhZGRpdGlvbmFsUHJvcGVydGllcyB9IDoge307XG4gICAgY29uc3QgcmVxdWlyZWRQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoem9kUmVmLnNoYXBlKS5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gem9kUmVmLnNoYXBlW2tleV07XG4gICAgICAgIHJldHVybiAoIShpdGVtLmlzT3B0aW9uYWwoKSB8fFxuICAgICAgICAgICAgaXRlbSBpbnN0YW5jZW9mIHpvZF8xLnouWm9kRGVmYXVsdCB8fFxuICAgICAgICAgICAgaXRlbS5fZGVmLnR5cGVOYW1lID09PSAnWm9kRGVmYXVsdCcpICYmICEoaXRlbSBpbnN0YW5jZW9mIHpvZF8xLnouWm9kTmV2ZXIgfHwgaXRlbS5fZGVmLnR5cGVOYW1lID09PSAnWm9kRGVmYXVsdCcpKTtcbiAgICB9KTtcbiAgICBjb25zdCByZXF1aXJlZCA9IHJlcXVpcmVkUHJvcGVydGllcy5sZW5ndGggPiAwID8geyByZXF1aXJlZDogcmVxdWlyZWRQcm9wZXJ0aWVzIH0gOiB7fTtcbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogWydvYmplY3QnXSwgcHJvcGVydGllczogaXRlcmF0ZVpvZE9iamVjdCh7XG4gICAgICAgICAgICB6b2RSZWY6IHpvZFJlZixcbiAgICAgICAgICAgIHNjaGVtYXMsXG4gICAgICAgICAgICB1c2VPdXRwdXQsXG4gICAgICAgICAgICBoaWRlRGVmaW5pdGlvbnM6IGdldEV4Y2x1ZGVkRGVmaW5pdGlvbnNGcm9tU2NoZW1hKHNjaGVtYXMpLFxuICAgICAgICB9KSB9LCByZXF1aXJlZCksIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKSwgaGlkZURlZmluaXRpb25zKSwgem9kUmVmLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogem9kUmVmLmRlc2NyaXB0aW9uLCBoaWRlRGVmaW5pdGlvbnMgfSA6IHt9LCAuLi5zY2hlbWFzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVjb3JkKHsgem9kUmVmLCBzY2hlbWFzLCB1c2VPdXRwdXQsIH0pIHtcbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKHtcbiAgICAgICAgdHlwZTogWydvYmplY3QnXSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHpvZFJlZi5fZGVmLnZhbHVlVHlwZSBpbnN0YW5jZW9mIHpvZF8xLnouWm9kVW5rbm93blxuICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgOiBnZW5lcmF0ZVNjaGVtYSh6b2RSZWYuX2RlZi52YWx1ZVR5cGUsIHVzZU91dHB1dCksXG4gICAgfSwgem9kUmVmLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogem9kUmVmLmRlc2NyaXB0aW9uIH0gOiB7fSwgLi4uc2NoZW1hcyk7XG59XG5mdW5jdGlvbiBwYXJzZUJpZ0ludCh7IHpvZFJlZiwgc2NoZW1hcywgfSkge1xuICAgIHJldHVybiAoMCwgdHNfZGVlcG1lcmdlXzEuZGVmYXVsdCkoeyB0eXBlOiBbJ2ludGVnZXInXSwgZm9ybWF0OiAnaW50NjQnIH0sIHpvZFJlZi5kZXNjcmlwdGlvbiA/IHsgZGVzY3JpcHRpb246IHpvZFJlZi5kZXNjcmlwdGlvbiB9IDoge30sIC4uLnNjaGVtYXMpO1xufVxuZnVuY3Rpb24gcGFyc2VCb29sZWFuKHsgem9kUmVmLCBzY2hlbWFzLCB9KSB7XG4gICAgcmV0dXJuICgwLCB0c19kZWVwbWVyZ2VfMS5kZWZhdWx0KSh7IHR5cGU6IFsnYm9vbGVhbiddIH0sIHpvZFJlZi5kZXNjcmlwdGlvbiA/IHsgZGVzY3JpcHRpb246IHpvZFJlZi5kZXNjcmlwdGlvbiB9IDoge30sIC4uLnNjaGVtYXMpO1xufVxuZnVuY3Rpb24gcGFyc2VEYXRlKHsgem9kUmVmLCBzY2hlbWFzIH0pIHtcbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKHsgdHlwZTogWydzdHJpbmcnXSwgZm9ybWF0OiAnZGF0ZS10aW1lJyB9LCB6b2RSZWYuZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uOiB6b2RSZWYuZGVzY3JpcHRpb24gfSA6IHt9LCAuLi5zY2hlbWFzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTnVsbCh7IHpvZFJlZiwgc2NoZW1hcyB9KSB7XG4gICAgcmV0dXJuICgwLCB0c19kZWVwbWVyZ2VfMS5kZWZhdWx0KSh7XG4gICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ251bGwnXSxcbiAgICAgICAgZW51bTogWydudWxsJ10sXG4gICAgfSwgem9kUmVmLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogem9kUmVmLmRlc2NyaXB0aW9uIH0gOiB7fSwgLi4uc2NoZW1hcyk7XG59XG5mdW5jdGlvbiBwYXJzZU9wdGlvbmFsKHsgc2NoZW1hcywgem9kUmVmLCB1c2VPdXRwdXQsIH0pIHtcbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKGdlbmVyYXRlU2NoZW1hKHpvZFJlZi51bndyYXAoKSwgdXNlT3V0cHV0KSwgem9kUmVmLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogem9kUmVmLmRlc2NyaXB0aW9uIH0gOiB7fSwgLi4uc2NoZW1hcyk7XG59XG5mdW5jdGlvbiBwYXJzZU51bGxhYmxlKHsgc2NoZW1hcywgem9kUmVmLCB1c2VPdXRwdXQsIH0pIHtcbiAgICBjb25zdCBzY2hlbWEgPSBnZW5lcmF0ZVNjaGVtYSh6b2RSZWYudW53cmFwKCksIHVzZU91dHB1dCk7XG4gICAgcmV0dXJuICgwLCB0c19kZWVwbWVyZ2VfMS5kZWZhdWx0KShzY2hlbWEsIHsgdHlwZTogWydudWxsJ10gfSwgem9kUmVmLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogem9kUmVmLmRlc2NyaXB0aW9uIH0gOiB7fSwgLi4uc2NoZW1hcyk7XG59XG5mdW5jdGlvbiBwYXJzZURlZmF1bHQoeyBzY2hlbWFzLCB6b2RSZWYsIHVzZU91dHB1dCwgfSkge1xuICAgIHJldHVybiAoMCwgdHNfZGVlcG1lcmdlXzEuZGVmYXVsdCkoT2JqZWN0LmFzc2lnbih7IGRlZmF1bHQ6IHpvZFJlZi5fZGVmLmRlZmF1bHRWYWx1ZSgpIH0sIGdlbmVyYXRlU2NoZW1hKHpvZFJlZi5fZGVmLmlubmVyVHlwZSwgdXNlT3V0cHV0KSksIHpvZFJlZi5kZXNjcmlwdGlvbiA/IHsgZGVzY3JpcHRpb246IHpvZFJlZi5kZXNjcmlwdGlvbiB9IDoge30sIC4uLnNjaGVtYXMpO1xufVxuZnVuY3Rpb24gcGFyc2VBcnJheSh7IHNjaGVtYXMsIHpvZFJlZiwgdXNlT3V0cHV0LCB9KSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSB7fTtcbiAgICBpZiAoem9kUmVmLl9kZWYuZXhhY3RMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBjb25zdHJhaW50cy5taW5JdGVtcyA9IHpvZFJlZi5fZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICBjb25zdHJhaW50cy5tYXhJdGVtcyA9IHpvZFJlZi5fZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoem9kUmVmLl9kZWYubWluTGVuZ3RoICE9IG51bGwpXG4gICAgICAgIGNvbnN0cmFpbnRzLm1pbkl0ZW1zID0gem9kUmVmLl9kZWYubWluTGVuZ3RoLnZhbHVlO1xuICAgIGlmICh6b2RSZWYuX2RlZi5tYXhMZW5ndGggIT0gbnVsbClcbiAgICAgICAgY29uc3RyYWludHMubWF4SXRlbXMgPSB6b2RSZWYuX2RlZi5tYXhMZW5ndGgudmFsdWU7XG4gICAgcmV0dXJuICgwLCB0c19kZWVwbWVyZ2VfMS5kZWZhdWx0KShPYmplY3QuYXNzaWduKHsgdHlwZTogWydhcnJheSddLCBpdGVtczogZ2VuZXJhdGVTY2hlbWEoem9kUmVmLmVsZW1lbnQsIHVzZU91dHB1dCkgfSwgY29uc3RyYWludHMpLCB6b2RSZWYuZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uOiB6b2RSZWYuZGVzY3JpcHRpb24gfSA6IHt9LCAuLi5zY2hlbWFzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTGl0ZXJhbCh7IHNjaGVtYXMsIHpvZFJlZiwgfSkge1xuICAgIHJldHVybiAoMCwgdHNfZGVlcG1lcmdlXzEuZGVmYXVsdCkoe1xuICAgICAgICB0eXBlOiBbdHlwZW9mIHpvZFJlZi5fZGVmLnZhbHVlXSxcbiAgICAgICAgZW51bTogW3pvZFJlZi5fZGVmLnZhbHVlXSxcbiAgICB9LCB6b2RSZWYuZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uOiB6b2RSZWYuZGVzY3JpcHRpb24gfSA6IHt9LCAuLi5zY2hlbWFzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRW51bSh7IHNjaGVtYXMsIHpvZFJlZiwgfSkge1xuICAgIHJldHVybiAoMCwgdHNfZGVlcG1lcmdlXzEuZGVmYXVsdCkoe1xuICAgICAgICB0eXBlOiBbdHlwZW9mIE9iamVjdC52YWx1ZXMoem9kUmVmLl9kZWYudmFsdWVzKVswXV0sXG4gICAgICAgIGVudW06IE9iamVjdC52YWx1ZXMoem9kUmVmLl9kZWYudmFsdWVzKSxcbiAgICB9LCB6b2RSZWYuZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uOiB6b2RSZWYuZGVzY3JpcHRpb24gfSA6IHt9LCAuLi5zY2hlbWFzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW50ZXJzZWN0aW9uKHsgc2NoZW1hcywgem9kUmVmLCB1c2VPdXRwdXQsIH0pIHtcbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKHtcbiAgICAgICAgYWxsT2Y6IFtcbiAgICAgICAgICAgIGdlbmVyYXRlU2NoZW1hKHpvZFJlZi5fZGVmLmxlZnQsIHVzZU91dHB1dCksXG4gICAgICAgICAgICBnZW5lcmF0ZVNjaGVtYSh6b2RSZWYuX2RlZi5yaWdodCwgdXNlT3V0cHV0KSxcbiAgICAgICAgXSxcbiAgICB9LCB6b2RSZWYuZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uOiB6b2RSZWYuZGVzY3JpcHRpb24gfSA6IHt9LCAuLi5zY2hlbWFzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVW5pb24oeyBzY2hlbWFzLCB6b2RSZWYsIHVzZU91dHB1dCwgfSkge1xuICAgIGNvbnN0IGNvbnRlbnRzID0gem9kUmVmLl9kZWYub3B0aW9ucztcbiAgICBpZiAoY29udGVudHMucmVkdWNlKChwcmV2LCBjb250ZW50KSA9PiBwcmV2ICYmIGNvbnRlbnQuX2RlZi50eXBlTmFtZSA9PT0gJ1pvZExpdGVyYWwnLCB0cnVlKSkge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gdHJhbnNmb3JtIHVuaW9ucyBvZiBsaXRlcmFscyBpbnRvIGVudW1zXG4gICAgICAgIGNvbnN0IGxpdGVyYWxzID0gY29udGVudHM7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBsaXRlcmFscy5yZWR1Y2UoKHByZXYsIGNvbnRlbnQpID0+ICFwcmV2IHx8IHByZXYgPT09IHR5cGVvZiBjb250ZW50Ll9kZWYudmFsdWVcbiAgICAgICAgICAgID8gdHlwZW9mIGNvbnRlbnQuX2RlZi52YWx1ZVxuICAgICAgICAgICAgOiBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHNfZGVlcG1lcmdlXzEuZGVmYXVsdCkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFt0eXBlXSxcbiAgICAgICAgICAgICAgICBlbnVtOiBsaXRlcmFscy5tYXAoKGxpdGVyYWwpID0+IGxpdGVyYWwuX2RlZi52YWx1ZSksXG4gICAgICAgICAgICB9LCB6b2RSZWYuZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uOiB6b2RSZWYuZGVzY3JpcHRpb24gfSA6IHt9LCAuLi5zY2hlbWFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKHtcbiAgICAgICAgb25lT2Y6IGNvbnRlbnRzLm1hcCgoc2NoZW1hKSA9PiBnZW5lcmF0ZVNjaGVtYShzY2hlbWEsIHVzZU91dHB1dCkpLFxuICAgIH0sIHpvZFJlZi5kZXNjcmlwdGlvbiA/IHsgZGVzY3JpcHRpb246IHpvZFJlZi5kZXNjcmlwdGlvbiB9IDoge30sIC4uLnNjaGVtYXMpO1xufVxuZnVuY3Rpb24gcGFyc2VEaXNjcmltaW5hdGVkVW5pb24oeyBzY2hlbWFzLCB6b2RSZWYsIHVzZU91dHB1dCwgfSkge1xuICAgIHJldHVybiAoMCwgdHNfZGVlcG1lcmdlXzEuZGVmYXVsdCkoe1xuICAgICAgICBkaXNjcmltaW5hdG9yOiB7XG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHpvZFJlZi5fZGVmLmRpc2NyaW1pbmF0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIG9uZU9mOiBBcnJheS5mcm9tKHpvZFJlZi5fZGVmLm9wdGlvbnMudmFsdWVzKCkpLm1hcCgoc2NoZW1hKSA9PiBnZW5lcmF0ZVNjaGVtYShzY2hlbWEsIHVzZU91dHB1dCkpLFxuICAgIH0sIHpvZFJlZi5kZXNjcmlwdGlvbiA/IHsgZGVzY3JpcHRpb246IHpvZFJlZi5kZXNjcmlwdGlvbiB9IDoge30sIC4uLnNjaGVtYXMpO1xufVxuZnVuY3Rpb24gcGFyc2VOZXZlcih7IHpvZFJlZiwgc2NoZW1hcywgfSkge1xuICAgIHJldHVybiAoMCwgdHNfZGVlcG1lcmdlXzEuZGVmYXVsdCkoeyByZWFkT25seTogdHJ1ZSB9LCB6b2RSZWYuZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uOiB6b2RSZWYuZGVzY3JpcHRpb24gfSA6IHt9LCAuLi5zY2hlbWFzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQnJhbmRlZCh7IHNjaGVtYXMsIHpvZFJlZiwgfSkge1xuICAgIHJldHVybiAoMCwgdHNfZGVlcG1lcmdlXzEuZGVmYXVsdCkoZ2VuZXJhdGVTY2hlbWEoem9kUmVmLl9kZWYudHlwZSksIC4uLnNjaGVtYXMpO1xufVxuZnVuY3Rpb24gY2F0Y2hBbGxQYXJzZXIoeyB6b2RSZWYsIHNjaGVtYXMsIH0pIHtcbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKHpvZFJlZi5kZXNjcmlwdGlvbiA/IHsgZGVzY3JpcHRpb246IHpvZFJlZi5kZXNjcmlwdGlvbiB9IDoge30sIC4uLnNjaGVtYXMpO1xufVxuZnVuY3Rpb24gcGFyc2VQaXBlbGluZSh7IHNjaGVtYXMsIHpvZFJlZiwgdXNlT3V0cHV0LCB9KSB7XG4gICAgcmV0dXJuICgwLCB0c19kZWVwbWVyZ2VfMS5kZWZhdWx0KShnZW5lcmF0ZVNjaGVtYSh1c2VPdXRwdXQgPyB6b2RSZWYuX2RlZi5vdXQgOiB6b2RSZWYuX2RlZi5pbiwgdXNlT3V0cHV0KSwgLi4uc2NoZW1hcyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlYWRvbmx5KHsgem9kUmVmLCB1c2VPdXRwdXQsIHNjaGVtYXMsIH0pIHtcbiAgICByZXR1cm4gKDAsIHRzX2RlZXBtZXJnZV8xLmRlZmF1bHQpKGdlbmVyYXRlU2NoZW1hKHpvZFJlZi5fZGVmLmlubmVyVHlwZSwgdXNlT3V0cHV0KSwgem9kUmVmLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogem9kUmVmLmRlc2NyaXB0aW9uIH0gOiB7fSwgLi4uc2NoZW1hcyk7XG59XG5jb25zdCB3b3JrZXJNYXAgPSB7XG4gICAgWm9kT2JqZWN0OiBwYXJzZU9iamVjdCxcbiAgICBab2RSZWNvcmQ6IHBhcnNlUmVjb3JkLFxuICAgIFpvZFN0cmluZzogcGFyc2VTdHJpbmcsXG4gICAgWm9kTnVtYmVyOiBwYXJzZU51bWJlcixcbiAgICBab2RCaWdJbnQ6IHBhcnNlQmlnSW50LFxuICAgIFpvZEJvb2xlYW46IHBhcnNlQm9vbGVhbixcbiAgICBab2REYXRlOiBwYXJzZURhdGUsXG4gICAgWm9kTnVsbDogcGFyc2VOdWxsLFxuICAgIFpvZE9wdGlvbmFsOiBwYXJzZU9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBwYXJzZU51bGxhYmxlLFxuICAgIFpvZERlZmF1bHQ6IHBhcnNlRGVmYXVsdCxcbiAgICBab2RBcnJheTogcGFyc2VBcnJheSxcbiAgICBab2RMaXRlcmFsOiBwYXJzZUxpdGVyYWwsXG4gICAgWm9kRW51bTogcGFyc2VFbnVtLFxuICAgIFpvZE5hdGl2ZUVudW06IHBhcnNlRW51bSxcbiAgICBab2RUcmFuc2Zvcm1lcjogcGFyc2VUcmFuc2Zvcm1hdGlvbixcbiAgICBab2RFZmZlY3RzOiBwYXJzZVRyYW5zZm9ybWF0aW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogcGFyc2VJbnRlcnNlY3Rpb24sXG4gICAgWm9kVW5pb246IHBhcnNlVW5pb24sXG4gICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uOiBwYXJzZURpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICBab2ROZXZlcjogcGFyc2VOZXZlcixcbiAgICBab2RCcmFuZGVkOiBwYXJzZUJyYW5kZWQsXG4gICAgLy8gVE9ETyBUcmFuc2Zvcm0gdGhlIHJlc3QgdG8gc2NoZW1hc1xuICAgIFpvZFVuZGVmaW5lZDogY2F0Y2hBbGxQYXJzZXIsXG4gICAgLy8gVE9ETzogYHByZWZpeEl0ZW1zYCBpcyBhbGxvd2VkIGluIE9wZW5BUEkgMy4xIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSB0dXBsZXNcbiAgICBab2RUdXBsZTogY2F0Y2hBbGxQYXJzZXIsXG4gICAgWm9kTWFwOiBjYXRjaEFsbFBhcnNlcixcbiAgICBab2RGdW5jdGlvbjogY2F0Y2hBbGxQYXJzZXIsXG4gICAgWm9kTGF6eTogY2F0Y2hBbGxQYXJzZXIsXG4gICAgWm9kUHJvbWlzZTogY2F0Y2hBbGxQYXJzZXIsXG4gICAgWm9kQW55OiBjYXRjaEFsbFBhcnNlcixcbiAgICBab2RVbmtub3duOiBjYXRjaEFsbFBhcnNlcixcbiAgICBab2RWb2lkOiBjYXRjaEFsbFBhcnNlcixcbiAgICBab2RQaXBlbGluZTogcGFyc2VQaXBlbGluZSxcbiAgICBab2RSZWFkb25seTogcGFyc2VSZWFkb25seSxcbn07XG5mdW5jdGlvbiBnZW5lcmF0ZVNjaGVtYSh6b2RSZWYsIHVzZU91dHB1dCkge1xuICAgIGNvbnN0IHsgbWV0YU9wZW5BcGkgPSB7fSB9ID0gem9kUmVmO1xuICAgIGNvbnN0IHNjaGVtYXMgPSBbXG4gICAgICAgIC4uLihBcnJheS5pc0FycmF5KG1ldGFPcGVuQXBpKSA/IG1ldGFPcGVuQXBpIDogW21ldGFPcGVuQXBpXSksXG4gICAgXTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB0eXBlTmFtZSA9IHpvZFJlZi5fZGVmLnR5cGVOYW1lO1xuICAgICAgICBpZiAodHlwZU5hbWUgaW4gd29ya2VyTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya2VyTWFwW3R5cGVOYW1lXSh7XG4gICAgICAgICAgICAgICAgem9kUmVmOiB6b2RSZWYsXG4gICAgICAgICAgICAgICAgc2NoZW1hcyxcbiAgICAgICAgICAgICAgICB1c2VPdXRwdXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2F0Y2hBbGxQYXJzZXIoeyB6b2RSZWYsIHNjaGVtYXMgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gY2F0Y2hBbGxQYXJzZXIoeyB6b2RSZWYsIHNjaGVtYXMgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5nZW5lcmF0ZVNjaGVtYSA9IGdlbmVyYXRlU2NoZW1hO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9em9kLW9wZW5hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@anatine/zod-openapi/src/lib/zod-openapi.js\n");

/***/ })

};
;